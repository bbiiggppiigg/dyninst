\section{Interface}
This section describes functions in the API.  The API is organized as a collection of C++ classes. The primary classes are \BPatch, \BPatchprocess, \BPatchbinaryEdit, \BPatchthread, \BPatchimage, \BPatchpoint, and \BPatchsnippet. The API also uses a template class called std::vector.  This class is based on the Standard Template Library (STL) vector class. 

\newenvironment{myenv}{\begin{adjustwidth}{1cm}{}}{\end{adjustwidth}}
\newcommand{\manual}[2]{\mbox{}\code{#1}
\begin{myenv}
#2	
\end{myenv}
}
\newcommand{\BPatchexploratoryMode}[0]{\texttt{BPatch\_exploratoryMode}\xspace}
\newcommand{\BPatchnormalMode}[0]{\texttt{BPatch\_normalMode}\xspace}
\newcommand{\BPatchdefensiveMode}[0]{\texttt{BPatch\_defensiveMode}\xspace}
\subsection{CLASS BPatch}

The BPatch class represents the entire Dyninst library.  There can only be one instance of this class at a time.  This class is used to perform functions and obtain information that is not specific to a particular thread or image.

\manual{std::vector<BPatch\_process*> *getProcesses()}{
Returns the list of processes that are currently defined.  This list includes processes that were directly created by calling processCreate/processAttach, and indirectly by the UNIX fork or the Windows CreateProcess system call.   It is up to the user to delete this vector when they are done with it.	}

\manual{BPatch\_process *processAttach(const char *path, int pid, BPatch\_hybridMode mode=BPatch\_normalMode)\\
BPatch\_process *processCreate(const char *path, const char *argv[], const char **envp = NULL, int stdin\_fd=0, int stdout\_fd=1, int stderr\_fd=2, BPatch\_hybridMode mode=BPatch\_normalMode)  }{Each of these functions returns a pointer to a new instance of the BPatch\_process class.  The path parameter needed by these functions should be the pathname of the executable file containing the process image. The processAttach function returns a BPatch\_process associated with an existing process.  On Linux platforms the path parameter can be NULL since the executable image can be derived from the process pid.  Attaching to a process puts it into the stopped state.  The processCreate function creates a new process and returns a new BPatch\_process associated with it.  The new process is put into a stopped state be-fore executing any code.\\

The stdin\_fd, stdout\_fd, and stderr\_fd parameters are used to set the standard input, output, and error of the child process.  The default values of these parameters leave the input, output, and error to be the same as the mutator process.  To change these values, an open UNIX file descriptor (see open(1)) can be passed.\\

The \texttt{mode} parameter is used to select the desired level of code analysis.  Activating hybrid code analysis causes Dyninst to augment its static analysis of the code with run-time code discovery techniques. There are three modes:  \BPatchnormalMode, \BPatchexploratoryMode, and \BPatchdefensiveMode. Normal mode enables the regular static analysis features of Dyninst. Exploratory mode and defensive mode enable addtional dynamic features to correctly analyze programs that contain uncommon code patterns, such as malware. Exploratory mode is primarily oriented towards analyzing dynamic control transfers, while defensive mode additionally aims to tackle code obfuscation and self-modifying code. Both of these modes are still experimental and should be used with caution. Defensive mode is only supported on Windows.\\

Defensive mode has been tested on normal binaries (binaries that run correctly under normal mode), as well as some simple, packed executables (self-decrypting or decompressing). More advanced forms of code obfuscation, such as self-modifying code, have not been tested recently. The traditional Dyninst interface may be used for instrumentation of binaries in defensive mode, but in the case of highly obfuscated code, this interface may prove to be ineffective due to the lack of a complete view of control flow at any given point. Therefore, defensive mode also includes a set of callbacks that enables instrumentation to be performed as new code is discovered. Due to the fact that recent efforts have focused on simpler forms of obfuscation, these callbacks have not been tested in detail. The next release of Dyninst will target more advanced uses of defensive mode.
}

\manual{BPatch\_binaryEdit *openBinary(const char *path, 
bool openDependencies = false)}{
This function opens the executable file or library file pointed to by path for binary rewrit-ing.  If \texttt{openDependencies} is true then Dyninst will also open all shared libraries that path depends on.  Upon success, this function returns a new instance of a \BPatchbinaryEdit class that represents the opened file and any dependent shared libraries.  This function re-turns NULL in the event of an error.
}
\newcommand{\false}[0]{\texttt{false}\xspace}
\newcommand{\true}[0]{\texttt{true}\xspace}
\manual{
bool pollForStatusChange()}{
This is useful for a mutator that needs to periodically check on the status of its managed threads and does not want to check each process individually.  It returns true if there has been a change in the status of one or more threads that has not yet been reported by either \texttt{isStopped} or \texttt{isTerminated}.
}

\manual{
void setDebugParsing (bool state)}{
Turn on or off the parsing of debugger information.  By default, the debugger information (produced by the –g compiler option) is parsed on those platforms that support it.  However, for some applications this information can be quite large.  To disable parsing this information, call this method with a value of \false prior to creating a process. 
}

\manual{
bool parseDebugInfo()}{
Return true if debugger information parsing is enabled, or \false otherwise.
}

\manual{
void setTrampRecursive (bool state)}{
Turn on or off trampoline recursion.  By default, any snippets invoked while another snip-pet is active will not be executed.  This is the safest behavior, since recursively-calling snippets can cause a program to take up all available system resources and die.  For example, adding instrumentation code to the start of printf, and then calling printf from that snippet will result in infinite recursion.\\

This protection operates at the granularity of an instrumentation point.  When snippets are first inserted at a point, this flag determines whether code will be created with recursion protection.  Changing the flag is \emph{\textbf{not}} retroactive, and inserting more snippets will not change the recursion protection of the point.  Recursion protection increases the overhead of instrumentation points, so if there is no way for the snippets to call themselves, calling this method with the parameter \true will result in a performance gain.  The default value of this flag is \false.
}

\manual{bool isTrampRecursive ()}{
Return whether trampoline recursion is enabled or not.  \texttt{True} means that it is enabled.
}

\manual{void setTypeChecking(bool state)}{
Turn on or off type-checking of snippets.  By default type-checking is turned on, and an attempt to create a snippet that contains type conflicts will fail.  Any snippet expressions created with type-checking off have the type of their left operand.  Turning type-checking off, creating a snippet, and then turning type-checking back on is similar to the type cast operation in the C programming language. 
}

\manual{
bool isTypeChecked()}{
Return \true if type-checking of snippets is enabled, or \false otherwise.
}

\manual{
bool waitForStatusChange()}{
This function waits until there is a status change to some thread that has not yet been re-ported by either isStopped or isTerminated, and then returns true.  It is more efficient to call this function than to call pollForStatusChange in a loop, because waitFor-StatusChange blocks the mutator process while waiting.
}

\manual{
void setDelayedParsing (bool)}{
Turn on or off delayed parsing. When it is activated Dyninst will initially parse only the symbol table information in any new modules loaded by the program, and will postpone more thorough analysis (instrumentation point analysis, variable analysis, and discovery of new functions in stripped binaries).  This analysis will automatically occur when the infor-mation is necessary.\\

Users which require small run-time perturbation of a program should not delay parsing; the overhead for analysis may occur at unexpected times if it is triggered by internal Dyninst behavior.  Users who desire instrumentation of a small number of functions will benefit from delayed parsing.
}

\manual{
bool delayedParsingOn()}
{
Return \true if delayed parsing is enabled, or \false otherwise.
}


\manual{void setInstrStackFrames(bool)}{
Turn on and off stack frames in instrumentation.  When on, Dyninst will create stack frames around instrumentation.  A stack frame allows Dyninst or other tools to walk a call stack through instrumentation, but introduces overhead to instrumentation.  The default is to not create stack frames.}

\manual{bool getInstrStackFrames()}{
Return \true if instrumentation will create stack frames, or \false otherwise.  }

\manual{void setMergeTramp (bool)}{
Turn on or off inlined tramps.  Setting this value to \true will make each base trampoline have all of its mini-trampolines inlined within it.  Using inlined mini-tramps may allow instrumentation to execute faster, but inserting and removing instrumentation may take more time.  The default setting for this is \true.}

\manual{bool isMergeTramp ()}{
This returns the current status of inlined trampolines.  A value of \true indicates that trampolines are inlined.}

\manual{void setSaveFPR (bool)}{
Turn on or off floating point saves.  Setting this value to false means that floating point registers will never be saved, which can lead to large performance improvements.  The default value is \true.  Setting this flag may cause incorrect program behavior if the instrumentation does clobber floating point registers, so it should only be used when the user is positive this will never happen.}

\manual{bool isSaveFPROn ()}{
This returns the current status of the floating point saves. \texttt{True} means we are saving float-ing points based on the analysis for the given platform.}

\manual{void setBaseTrampDeletion(bool)}{
If \true, we delete the base tramp when the last corresponding minitramp is deleted.  If \false, we leave the base tramp in.  The default value is \false.}

\manual{bool baseTrampDeletion()}{
Return \true if base trampolines are set to be deleted, or \false otherwise.}

\manual{void setLivenessAnalysis(bool)}{
If \true, we perform register liveness analysis around an instPoint before inserting instrumentation, and we only save registers that are live at that point.  This can lead to faster run-time speeds, but at the expense of slower instrumentation time.  The default value is \true.}

\manual{bool livenessAnalysisOn()}{
Return \true if liveness analysis is currently enabled.}

\manual{void getBPatchVersion(int \&major, int \&minor, int \&subminor)}{
Return Dyninst’s version number.  The major version number will be stored in major, the minor version number in minor, and the subminor version in subminor.  For example, under Dyninst 5.1.0, this function will return 5 in major, 1 in minor, and 0 in subminor.}

\manual{int getNotificationFD()}{
Returns a file descriptor that is suitable for inclusion in a call to select(). Dyninst will write data to this file descriptor when it to signal a state change in the process.  \texttt{BPatch::pollForStatusChange} should then be called so that Dyninst can handle the state change.  This is useful for applications where the user does not want to block in \texttt{BPatch::waitForStatusChange}.  The file descriptor will reset when the user calls \texttt{BPatch::pollForStatusChange}.}

\manual{BPatch\_type *createArray(const char *name, BPatch\_type *ptr, unsigned int low, unsigned int hi) }{
Create a new array type.  The name of the type is name, and the type of each element is ptr.  The index of the first element of the array is low, and the last is high.  The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with arrays created using this function.}

\manual{BPatch\_type *createEnum(const char *name, std::vector<char *> \&elementNames, std::vector<int> \&elementIds) \\
BPatch\_type *createEnum(const char *name, std::vector<char *> \&elementNames)}{
Create a new enumerated type. There are two variations of this function.  The first one is used to create an enumerated type where the user specifies the identifier (int) for each element.  In the second form, the system specifies the identifiers for each element.  In both cases, a vector of character arrays is passed to supply the names of the elements of the enumerated type.  In the first form of the function, the number of element in the element-Names and elementIds vectors must be the same, or the type will not be created and this function will return NULL. The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with enums created using this function.}

\manual{BPatch\_type *createScalar(const char *name, int size) }{
Create a new scalar type.  The name field is used to specify the name of the type, and the size parameter is used to specify the size in bytes of each instance of the type.  No additional information about this type is supplied.  The type is compatible with other scalars with the same name and size.}

\manual{BPatch\_type *createStruct(const char *name, std::vector<char *> \&fieldNames, std::vector<BPatch\_type *> \&fieldTypes) }{
Create a new structure type.  The name of the structure is specified in the name parameter.  The fieldNames and fieldTypes vectors specify fields of the type.  These two vectors must have the same number of elements or the function will fail (and return NULL). The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with structures created using this function. The size of the structure is the sum of the size of the elements in the fieldTypes vector.}

\manual{BPatch\_type *createTypedef(const char *name, BPatch\_type *ptr) }{
Create a new type called name and having the type ptr. }

\manual{BPatch\_type *createPointer(const char *name, BPatch\_type *ptr)\\
BPatch\_type *createPointer(const char *name, BPatch\_type *ptr, int size)}{ 
Create a new type, named name, which points to objects of type ptr. The first form creates a pointer whose size is equal to sizeof(void*)on the target platform where the mutatee is running.  In the second form, the size of the pointer is the value passed in the size parameter.}

\manual{BPatch\_type *createUnion(const char *name, std::vector<char *> \&fieldNames, std::vector<BPatch\_type *> \&fieldTypes) }{
Create a new union type.  The name of the union is specified in the name parameter.  The fieldNames and fieldTypes vectors specify fields of the type.  These two vectors must have the same number of elements or the function will fail (and return NULL). The size of the union is the size of the largest element in the fieldTypes vector.
}


\subsection{Callbacks}

The following functions are intended as a way for API users to be informed when an error or significant event occurs.  Each function allows a user to register a handler for an event.  The return code for all callback registration functions is the address of the handler that was previously registered (which may be NULL if no handler was previously registered).  For backwards compatibility reasons, some callbacks may pass a \BPatchthread object when a \BPatchprocess may be more appropriate.  A \BPatchthread may be converted into a \BPatchprocess using \texttt{BPatch\_thread::getProcess()}.

\subsubsection{Asynchronous Callbacks}


\manual{typedef void (*BPatchAsyncThreadEventCallback)(
BPatch\_process *proc, BPatch\_thread *thread)\\
bool registerThreadEventCallback(BPatch\_asyncEventType type,
BPatchAsyncThreadEventCallback cb)\\
bool removeThreadEventCallback(BPatch\_asyncEventType type,
	BPatch\_AsyncThreadEventCallback cb)
}{
The type parameter can be either one of BPatch\_threadCreateEvent or BPatch\_threadDestroyEvent.  Different callbacks can be registered for different values of type.
}


\subsubsection{Code Discovery Callbacks}

\manual{
typedef void (*BPatchCodeDiscoveryCallback)( BPatch\_Vector<BPatch\_function*> \&newFuncs,                BPatch\_Vector<BPatch\_function*> \&modFuncs)\\
bool registerCodeDiscoveryCallback(BPatchCodeDiscoveryCallback cb)\\
bool removeCodeDiscoveryCallback(BPatchCodeDiscoveryCallback cb)}{
This callback is invoked whenever previously un-analyzed code is discovered through runtime analysis, and delivers a vector of functions whose analysis have been modified and a vector of functions that are newly discovered.}


\subsubsection{Code Overwrite Callbacks}
\manual{
typedef void (*BPatchCodeOverwriteBeginCallback)(\\
\indent BPatch\_Vector<BPatch\_basicBlock*> \&overwriteLoopBlocks);\\
typedef void (*BPatchCodeOverwriteEndCallback)(\\
\indent BPatch\_Vector<std::pair<Dyninst::Address,int> > \&deadBlocks, \\
\indent BPatch\_Vector<BPatch\_function*> \&owFuncs,\\
\indent BPatch\_Vector<BPatch\_function*> \&modFuncs, \\
\indent BPatch\_Vector<BPatch\_function*> \&newFuncs)\\
bool registerCodeOverwriteCallbacks(
\\ 
\indent BPatchCodeOverwriteBeginCallback cbBegin,\\ 
\indent BPatchCodeOverwriteEndCallback cbEnd)}{
Register a callback at the beginning and end of overwrite events.  Only invoke if Dyninst's hybrid analysis mode is set to \BPatchdefensiveMode.\\

The \texttt{BPatchCodeOverwriteBeginCallback} callback allows the user to remove any in-strumentation when the program starts writing to a code page, which may be desirable as instrumentation cannot be removed during the overwrite loop's execution, and any break-point instrumentation will dramatically slow the loop's execution.\\

The \texttt{BPatchCodeOverwriteEndCallback} callback delivers the effects of the overwrite loop when it is done executing.  In many cases no code will have changed.
}
\newcommand{\NULL}[0]{\texttt{NULL}\xspace}

\subsubsection{Dynamic Calls}
\manual{
typedef void (*BPatchDynamicCallSiteCallback)(\\
\indent BPatch\_point *at\_point, BPatch\_function *called\_function);\\
bool registerDynamicCallCallback(BPatchDynamicCallSiteCallback cb);\\
bool removeDynamicCallCallback(BPatchDynamicCallSiteCallback cb);}{
The \texttt{registerDynamicCallCallback} interface will not automatically instrument any dynamic call site. To make sure the call back function is called, the user needs to explicitly in-strument dynamic call sites. One way to achieve this goal is to first get instrumentation points representing dynamic call sites and then call \texttt{BPatch\_point::monitorCalls} with a \NULL input parameter. 
}
\subsubsection{Dynamic Libraries}

\manual{
typedef void (*BPatchDynLibraryCallback)(BPatch\_thread *thr,\\
\indent BPatch\_object *obj, bool loaded);\\
BPatchDynLibraryCallback registerDynLibraryCallback(\\
\indent BPatchDynLibraryCallback func)}{
Note that in versions previous to 9.1, BPatchDynLibraryCallback’s signature took a BPatch\_module instead of a BPatch\_object.
}

\subsubsection{Errors}
\manual{
enum BPatchErrorLevel \{ \\
\indent BPatchFatal, BPatchSerious, BPatchWarning, BPatchInfo \};\\
typedef void (*BPatchErrorCallback)(\\
\indent BPatchErrorLevel severity, int number, const char * const *params)\\
BPatchErrorCallback registerErrorCallback(BPatchErrorCallback func)}{
This function registers the error callback function with the BPatch class.  The return value is the address of the previous error callback function. Dyninst users can change the error callback during program execution (e.g., one error callback before a GUI is initialized, and a different one after). The \texttt{severity} field indicates how important the error is (from fatal to information/status).  The \texttt{number} is a unique number that identifies this error message.  \texttt{Params} are the parameters that describe the detail about an error, e.g., the process id where the error occurred.  The number and meaning of params depends on the error.  However, for a given error number the number of parameters returned will always be the same.
}

\subsubsection{Exec}
\manual{
typedef void (*BPatchExecCallback)(BPatch\_thread *thr)\\
BPatchExecCallback registerExecCallback(BPatchExecCallback func) Not implemented on Windows.
 } {
  }

\subsubsection{Exit}

\manual{
typedef enum BPatch\_exitType { NoExit, ExitedNormally, ExitedViaSignal };\\
typedef void (*BPatchExitCallback)(\\
\indent BPatch\_thread *proc, BPatch\_exitType exit\_type);\\
BPatchExitCallback registerExitCallback(
BPatchExitCallback func) }{
Register a function to be called when a process terminates. For a normal process exit, the callback will actually be called just before the process exits, but while its process state still exists.  This allows final actions to be taken on the process before it actually exits.  The function \texttt{BPatch\_thread::isTerminated()} will return true in this context even though the process hasn’t yet actually exited.  In the case of an exit due to a signal, the process will have already exited.
}

\subsubsection{Fork}
\manual{
typedef void (*BPatchForkCallback)(BPatch\_thread *parent, BPatch\_thread *child);}{
This is the prototype for the pre-fork and post-fork callbacks.  The parent parameter is the parent thread, and the child parameter is a BPatch\_thread in the newly created pro-cess. When invoked as a pre-fork callback, the child is \NULL.}

\manual{
BPatchForkCallback registerPreForkCallback(\\
\indent BPatchForkCallback func) not implemented on Windows \\
BPatchForkCallback registerPostForkCallback(\\
\indent BPatchForkCallback func) not implemented on Windows}{
Register callbacks for pre-fork (before the child is created) and post-fork (immediately after the child is created). When a pre-fork callback is executed the child parameter will be \NULL.

}

\subsubsection{One Time Code}
\manual{
typedef void (*BPatchOneTimeCodeCallback)(Bpatch\_thread *thr,\\
\indent void *userData, void *returnValue);\\
BPatchOneTimeCodeCallback registerOneTimeCodeCallback(\\
\indent BPatchOneTimeCodeCallback func)}{
The thr field contains the thread that executed the \texttt{oneTimeCode} (if thread-specific) or an unspecified thread in the process (if process-wide).  The \texttt{userData} field contains the value passed to the oneTimeCode call. The \texttt{returnValue} field contains the return result of the oneTimeCode snippet.
}

\subsubsection{Signal Handler}

\manual{
typedef void (*BPatchSignalHandlerCallback)(BPatch\_point *at\_point,\\
\indent long signum, std::vector<Dyninst::Address> *handlers)\\
bool registerSignalHandlerCallback(BPatchSignalHandlerCallback cb, \\
\indent sstd::set<long> \&signal\_numbers)\\
bool registerSignalHandlerCallback(BPatchSignalHandlerCallback cb, \\
\indent BPatch\_Set<long> *signal\_numbers)\\
bool removeSignalHandlerCallback(BPatchSignalHandlerCallback cb);}{
This function registers the signal handler callback function with the \BPatch class.  The return value indicates success or failure. The signal\_numbers set contains those signal numbers for which the callback will be invoked.\\

The \texttt{at\_point} parameter indicates the point at which the signal/exception was raised, \texttt{signum} is the number of the signal/exception that was raised, and the \texttt{handlers} vector contains any registered handler(s) for the signal/exception.  In Windows this corresponds to the stack of Structured Exception Handlers, while for Unix systems there will be at most one registered exception handler.  This functionality is only fully implemented for the Windows platform. 
}
\subsubsection{Stopped Threads}
\newcommand{\stopThreadExpr}[0]{\texttt{stopThreadExpr}\xspace}
\manual{
typedef void (*BPatchStopThreadCallback)(BPatch\_point *at\_point, void *returnValue)}{
This is the prototype for the callback that is associated with the \stopThreadExpr snippet class (see Section 4.13).  Unlike the other callbacks in this section, \stopThreadExpr callbacks are registered during the creation of the \stopThreadExpr snippet type.  Whenever a \stopThreadExpr snippet executes in a given thread, the snippet evaluates the calculation snippet that \stopThreadExpr takes as a parameter, stops the thread’s execution and invokes this callback.  The \texttt{at\_point} parameter is the \BPatchpoint at which the \stopThreadExpr snippet was inserted, and returnValue contains the computation made by the calculation snippet.  

}
\subsubsection{User-triggered callbacks}

\manual{
typedef void (*BPatchUserEventCallback)(BPatch\_process *proc, void *buf, unsigned int bufsize);
bool registerUserEventCallback(BPatchUserEventCallback cb)
bool removeUserEventCallback(BPatchUserEventCallback cb)}{
Register a callback that is executed when the user sends a message from the mutatee using the \texttt{DYNINSTuserMessage} function in the runtime library. 
}

\subsection{CLASS BPATCH\_ADDRESSSPACE}


The \textbf{\BPatchaddressSpace} class is a superclass of the \BPatchprocess and \BPatchbinaryEdit classes.  It contains functionality that is common between the two sub classes.
 
\manual{BPatch\_image *getImage() }{
Return a handle to the executable file associated with this \BPatchprocess object. }
\newcommand{\addr}[0]{\texttt{addr}\xspace}

\manual{
bool getSourceLines(unsigned long addr, std::vector< BPatch\_statement > \& lines)}{
This function returns the line information associated with the mutatee address, \addr.  The vector \texttt{lines} contain pairs of filenames and line numbers that are associated with \addr.  In many cases only one filename and line number is associated with an address, but certain compiler optimizations may lead to multiple filenames and lines at an address.    This in-formation is only available if the mutatee was compiled with debug information.\\

This function returns \true if it was able to find any line information at addr, or \false otherwise.}

\manual{
bool getAddressRanges( const char * fileName, unsigned int lineNo, std::vector< std::pair< unsigned long, unsigned long > > \& ranges )}{
Given a filename and line number, fileName and lineNo, this function this function re-turns the ranges of mutatee addresses that implement the code range in the output parameter ranges.  In many cases a source code line will only have one address range implementing it. However, compiler optimizations may transform this into multiple disjoint address rang-es.  This information is only available if the mutatee was compiled with debug information.\\

This function returns \true if it was able to find any line information, \false otherwise.}

\manual{BPatch\_variableExpr *malloc(int n, \\
\indent std::string name = std::string("")) \\
BPatch\_variableExpr *malloc(const BPatch\_type \&type,\\
\indent std::string name = std::string("")) }{
These two functions allocate memory. Memory allocation is from a heap. The heap is not necessarily the same heap used by the application. The available space in the heap may be limited depending on the implementation. The first function, \texttt{malloc(int n)}, allocates n bytes of memory from the heap. The second function, \texttt{malloc(const BPatch\_type\& t)}, allocates enough memory to hold an object of the specified type. Using the second version is strongly encouraged because it provides additional information to permit better type checking of the passed code. If a name is specified, Dyninst will assign \texttt{var\_name} to the variable; otherwise, it will assign an internal name. The returned memory is persistent and will not be released until \texttt{BPatch\_process::free} is called or the application terminates.
}

\newcommand{\inmodule}[0]{\texttt{in\_module}\xspace}

\manual{BPatch\_variableExpr *createVariable(Dyninst::Address addr,\\
\indent	BPatch\_type *type,\\
\indent	std::string var\_name = std::string(“”),\\
\indent BPatch\_module *in\_module = NULL)}{
This method creates a new variable at the given address \addr in the module \inmodule.  If a name is specified, Dyninst will assign \texttt{var\_name} to the variable; otherwise, it will assign an internal name.  The type parameter will become the type for the new variable.\\
  
When operating in binary rewriting mode, it is an error for the \inmodule parameter to be \NULL; it is necessary to specify the module in which the variable will be created.  Dyninst will then write the variable back out in the file specified by \inmodule. 
}

\manual{bool free(BPatch\_variableExpr \&ptr) }{
Free the memory in the passed variable \texttt{ptr}. The programmer is responsible for verifying that all code that could reference this memory will not execute again (either by removing all snippets that refer to it, or by analysis of the program). Return \true if the free succeeded.}

\manual{bool getRegisters(std::vector<BPatch\_register> \&regs)}
{
This function returns a vector of \texttt{BPatch\_register} objects that represent registers available to snippet code.}

\manual{BPatchSnippetHandle *insertSnippet(const BPatch\_snippet \&expr, \\
\indent BPatch\_point \&point,\\
\indent BPatch\_callWhen when=[BPatch\_callBefore| BPatch\_callAfter],\\
\indent BPatch\_snipptOerder order = BPatch\_firstSnippet)\\
BPatchSnippetHandle *insertSnippet(const BPatch\_snippet \&expr,\\
\indent const std::vector<BPatch\_point *> \&points,\\
\indent BPatch\_callWhen when=[BPatch\_callBefore| BPatch\_callAfter], \\
\indent BPatch\_snippetOrder order = BPatch\_firstSnippet)}
{
Insert a snippet of code at the specified point. If a list of points is supplied, insert the code snippet at each point in the list. The optional when argument specifies when the snip-pet is to be called; a value of \texttt{BPatch\_callBefore} indicates that the snippet should be inserted just before the specified point or points in the code, and a value of \texttt{BPatch\_callAfter} indicates that it should be inserted just after them. \\

 The order argument specifies where the snippet is to be inserted relative to any other snippets previously inserted at the same point.  The values \texttt{BPatch\_firstSnippet} and \texttt{BPatch\_lastSnippet} indicate that the snippet should be inserted before or after all snip-pets, respectively.\\
 
It is illegal to use \texttt{BPatch\_callAfter} with a \texttt{BPatch\_entry point}.  Use \texttt{BPatch\_callBefore} when instrumenting entry points, which inserts instrumentation be-fore the first instruction in a subroutine.  Likewise, it is illegal to use \texttt{BPatch\_callBefore} with a \texttt{BPatch\_exit} point.  Use \texttt{BPatch\_callAfter} with exit points. \texttt{BPatch\_callAfter} inserts instrumentation at the last instruction in the subroutine. \texttt{insertSnippet} will return \NULL when used with an illegal pair of points.
}


\manual{bool deleteSnippet(BPatchSnippetHandle *handle)}{
Remove the snippet associated with the passed handle.  If the handle is not defined for the process, then deleteSnippet will return \false.}

\newcommand{\beginInsertionSet}[0]{\texttt{beginInsertionSet}\xspace}
\newcommand{\finalizeInsertionSet}[0]{\texttt{finalizeInsertionSet}\xspace}
\newcommand{\BPatchSnippetHandle}[0]{\texttt{BPatchSnippetHandle}\xspace}
\newcommand{\BPatchSnippetHandles}[0]{\texttt{BPatchSnippetHandles}\xspace}

\manual{void beginInsertionSet()}{
Normally, a call to \insertSnippet immediately injects instrumentation into the mutatee. However, users may wish to insert a set of snippets as a single batch operation. This provides two benefits: First, Dyninst may insert instrumentation in a more efficient manner. Second, multiple snippets may be inserted at multiple points as a single operation, with either all snippets being inserted successfully or none. This batch insertion mode is begun with a call to \beginInsertionSet; after this call, no snippets are actually inserted until a corresponding call to finalizeInsertionSet. Dyninst accumulates all calls to \insertSnippet during batch mode internally, and the returned \BPatchSnippetHandles are filled in when \finalizeInsertionSet is called.\\

Insertion sets are unnecessary when doing static binary instrumentation.  Dyninst uses an implicit insertion set around all instrumentation to a static binary.}

\manual{bool finalizeInsertionSet(bool atomic)}{
Inserts all snippets accumulated since a call to \beginInsertionSet. If the atomic parameter is \true, then a failure to insert any snippet results in all snippets being removed; effectively, the insertion is all-or-nothing. If the \texttt{atomic} parameter is false, then snippets are inserted individually. This function also fills in the BPatchSnippetHandle structures returned by the \insertSnippet calls comprising this insertion set.  It returns \true on success and \false if there was an error inserting any snippets.\\

Insertion sets are unnecessary when doing static binary instrumentation.  Dyninst uses an implicit insertion set around all instrumentation to a static binary.}

\manual{bool removeFunctionCall(BPatch\_point \&point)}{
Disable the mutatee function call at the specified location.  The \point specified must be a valid call point in the image of the mutatee. The purpose of this routine is to permit tools to alter the semantics of a program by eliminating procedure calls.  The mechanism to achieve the removal is platform dependent, but might include branching over the call or replacing it with NOPs. This function only removes a function call; any parameters to the function will still be evaluated.}

\manual{
bool replaceFunction (BPatch\_function \&old, BPatch\_function \&new)\\
bool revertReplaceFunction (BPatch\_function \&old)}{
Replace all calls to user function old with calls to new.  This is done by inserting instrumentation (specifically a BPatch\_funcJumpExpr) into the beginning of function old such that a non-returning jump is made to function new.  Returns \true upon success, false otherwise.}

\manual{bool replaceFunctionCall(BPatch\_point \&point, BPatch\_function \&newFunc)}{
Change the function call at the specified point to the function indicated by newFunc. The purpose of this routine is to permit runtime steering tools to change the behavior of pro-grams by replacing a call to one procedure by a call to another. Point must be a function call point. If the change was successful, the return value is true, otherwise false will be returned.\\

WARNING: Care must be used when replacing functions.  In particular if the compiler has performed inter-procedural register allocation between the original caller/callee pair, the replacement may not be safe since the replaced function may clobber registers the compiler thought the callee left untouched. Also the signatures of the both the function be-ing replaced and the new function must be compatible.}

\manual{bool wrapFunction(BPatch\_function *old, BPatch\_function *new, Dyninst::SymtabAPI::Symbol *sym)
bool revertWrapFunction(BPatch\_function *old)}{
Replaces all calls to function old with calls to function new. Unlike replaceFunction above, the old function can still be reached via the name specified by the provided symbol sym. Function wrapping allows existing code to be extended by new code. Consider the follow-ing code that implements a fast memory allocator for a particular size of memory allocation, but falls back to the original memory allocator (referenced by origMalloc) for all others.\\
\texttt{
void *origMalloc(unsigned long size); \\\\
void *fastMalloc(unsigned long size) \{\\
\indent	if (size == 1024) {\\
\indent\indent		unsigned long ret = fastPool; \\
\indent\indent		fastPool += 1024;\\
\indent\indent		return ret;\\
\indent	\}\\
\indent	else \{\\
\indent\indent		return origMalloc(size);\\
\indent	\}\\
\}\\}
}\\

The symbol sym is provided by the user and must exist in the program; the easiest way to ensure it is created is to use an undefined function as shown above with the definition of origMalloc. \\

The following code wraps malloc with fastMalloc, while allowing functions to still ac-cess the original malloc function by calling origMalloc. It makes use of the new convert interface described in Section 5.\\

\texttt{using namespace Dyninst;\\
using namespace SymtabAPI;\\
BPatch\_function *malloc = appImage->findFunction(...);\\
BPatch\_function *fastMalloc = appImage->findFunction(...);\\
Symtab *symtab = SymtabAPI::convert(fastMalloc->getModule());\\
std::vector<Symbol *> syms;\\
symtab->findSymbol(syms, "origMalloc", \\
\indent				Symbol::ST\_UNKNOWN, // Don’t specify type\\
\indent				mangledName, // Look for raw symbol name\\
\indent				false, // Not regular expression\\
\indent				false, // Don’t check case\\
\indent				true); // Include undefined symbols\\
app->wrapFunction(malloc, fastMalloc, syms[0]);
}\\

For a full, executable example, see Appendix~\ref{appdx:complete_examples} Complete Examples.


}




\manual{bool replaceCode(BPatch\_point *point, BPatch\_snippet *snippet)}
{This function has been removed; users interested in replacing code should instead use the PatchAPI code modification interface described in the PatchAPI manual. For information on accessing PatchAPI abstractions from DyninstAPI abstractions, see Section~\ref{sec:using_api}.}

\manual{BPatch\_module * loadLibrary(const char *libname, bool reload=\false)}{
For dynamic rewriting, this function loads a dynamically linked library into the process’s address space.  For static rewriting, this function adds a library as a library dependency in the rewritten file.  In both cases Dyninst creates a new BPatch\_module to represent this library.
The libname parameter identifies the file name of the library to be loaded, in the standard way that dynamically linked libraries are specified on the operating system on which the API is running.  This function returns a handle to the loaded library. The reload parameter is ignored and only remains for backwards compatibility.}

\manual{bool isStaticExecutable()}{
This function returns \true if the original file opened with this \BPatchaddressSpace is a statically linked executable, or \false otherwise.}

\manual{processType getType()}
{This function returns a processType that reflects whether this address space is a \BPatchprocess or a \BPatchbinaryEdit.}


\subsection{CLASS BPATCH\_PROCESS}\label{sec:bpatch_process}

The \textbf{\BPatchprocess} class represents a running process, which includes one or more threads of execution and an address space.

\manual{
bool stopExecution() \\
bool continueExecution()\\ 
bool terminateExecution()
}{
These three functions change the running state of the process. \texttt{stopExecution} puts the process into a stopped state. Depending on the operating system, stopping one process may stop all threads associated with a process. \texttt{continueExecution} continues execution of the process.  \texttt{terminateExecution} terminates execution of the process and will invoke the ex-it callback if one is registered. Each function returns true on success, or false for failure.  Stopping or continuing a terminated thread will fail and these functions will return false.
}

\manual{
bool isStopped() \\
int stopSignal() \\
bool isTerminated() }{
These three functions query the status of a process.  \texttt{isStopped} returns true if the process is currently stopped. If the process is stopped (as indicated by \texttt{isStopped}), then \texttt{stopSigsnal} can be called to find out what signal caused the process to stop. \texttt{isTerminated} returns true if the process has exited. Any of these functions may be called multiple times, and call-ing them will not affect the state of the process.
}



\manual{BPatch\_variableExpr *getInheritedVariable(BPatch\_variableExpr \&parentVar) }{
Retrieve a new handle to an existing variable (such as one created by \texttt{BPatch\_process::malloc}) that was created in a parent process and now exists in a forked child process.  When a process forks all existing \texttt{BPatch\_variableExprs} are copied to the child process, but the Dyninst handles for these objects are not valid in the child \texttt{BPatch\_process}.  This function is invoked on the child process’ \texttt{BPatch\_process}, \texttt{parentVar} is a variable from the parent process, and a handle to a variable in the child process is returned.  If \texttt{parentVar} was not allocated in the parent process, then \NULL is returned.}

\manual{BPatchSnippetHandle *getInheritedSnippet(\\
\indent BPatchSnippetHandle \&parentSnippet) }{
This function is similar to getInheritedVariable, but operates on \texttt{BPatchSnippetHandles}.  Given a child process that was created via fork and a \texttt{BPatchSnippetHandle}, \texttt{parentSnippet}, from the parent process, this function will return a handle to \texttt{parentSnippet} that is valid in the child process.  If it is determined that \texttt{parentSnippet} is not associated with the parent process, then \NULL is returned.}

\manual{void detach(bool cont)}{
Detach from the process.  The process must be stopped to call this function.  Instrumentation and other changes to the process will remain active in the detached copy. The cont parameter is used to indicate if the process should be continued as a result of detaching.  \\

Linux does not support detaching from a process while leaving it stopped.  All processes are continued after detach on Linux.}

\manual{int getPid()}
{Return the system id for the mutatee process.  On UNIX based systems this is a PID.  On Windows this is the HANDLE object for a process.}

\manual{typedef enum BPatch\_exitType \{ NoExit, ExitedNormally, ExitedViaSignal \};\\
BPatch\_exitType terminationStatus()}{
If the process has exited, \texttt{terminationStatus} will indicate whether the process exited normally or because of a signal.  If the process has not exited, \texttt{NoExit} will be returned. On AIX, the reason why a process exited will not be available if the process was not a child of the Dyninst mutator; in this case, \texttt{ExitedNormally} will be returned in both normal and signal exit cases.}


\manual{int getExitCode()}{
If the process exited in a normal way, \texttt{getExitCode} will return the associated exit code. Prior to Dyninst 8.2, \texttt{getExitCode} would return the argument passed to \texttt{exit} or the value returned by \texttt{main}; in Dyninst 8.2 and later, it returns the actual exit code as provided by the debug interface and seen by the parent process. In particular, on Linux, this means that exit codes are normalized to the range 0-255.
}


\newcommand{\expr}[0]{\texttt{expr}\xspace}

\manual{int getExitSignal()}{
If the process exited because of a received signal, getExitSignal will return the associated signal number.}
\manual{void oneTimeCode(const BPatch\_snippet \&expr) }{
Cause the snippet \texttt{expr} to be executed by the mutatee immediately. If the process is multi-threaded, the snippet is run on a thread chosen by Dyninst. If the user requires the snippet to be run on a particular thread, use the \BPatchthread version of this function instead. The process must be stopped to call this function.  The behavior is synchronous;\texttt{oneTime-Code} will not return until after the snippet has been run in the application.
}

\manual{bool oneTimeCodeAsync(const BPatch\_snippet \&expr, \\
\indent                      void *userData  = NULL) }{
This function sets up a snippet to be evaluated by the process at the next available opportunity. When the snippet finishes running Dyninst will callback any function registered through \texttt{BPatch::registerOneTimeCodeCallback}, with \texttt{userData} passed as a parameter.  This function return \true on success and \false if it could not post the \texttt{oneTimeCode}.\\

If the process is multithreaded, the snippet is run on a thread chosen by Dyninst. If the user requires the snippet to be run on a particular thread, use the \BPatchthread version of this function instead. The behavior is asynchronous; \texttt{oneTimeCodeAsync} returns before the snippet is executed.\\

If the process is running when \texttt{oneTimeCodeAsync} is called, \texttt{expr} will be run immediately.  If the process is stopped, then \expr will be run when the process is continued.}

\manual{void getThreads(std::vector<BPatch\_thread *> \&thrds)}{
Get the list of threads in the process.
}

\manual{bool isMultithreaded()\\
bool isMultithreadCapable()}{
The former returns true if the process contains multiple threads; the latter returns true if the process can create threads (e.g., it contains a threading library) even if it has not yet. 
}

\subsection{CLASS BPATCH\_THREAD}

The \textbf{\emph{\BPatchthread}} class represents and controls a thread of execution that is running in a pro-cess.


\manual{void getCallStack(std::vector<BPatch\_frame>\& stack)}{
This function fills the given vector with current information about the call stack of the thread.  Each stack frame is represented by a BPatch\_frame }(see section~\ref{sec:bpatch_frame} for information about this class).

\manual{dynthread\_t getTid()}{
This function returns a platform-specific identifier for this thread.  This is the identifier that is used by the threading library.  For example, on pthread applications this function will return the thread’s \texttt{pthread\_t} value.  }

\manual{Dyninst::LWP getLWP()}{
This function returns a platform-specific identifier that the operating system uses to identify this thread.  For example, on UNIX platforms this returns the LWP id.  On Windows this returns a HANDLE object for the thread.}

\manual{unsigned getBPatchID()}{
	This function returns a Dyninst-specific identifier for this thread.  These ID’s apply only to running threads, the BPatch ID of an already terminated thread my be repeated in a new thread.}

\manual{BPatch\_function *getInitialFunc()}{
Return the function that was used by the application to start this thread.  For example, on pthread applications this will return the initial function that was passed to pthread\_create.  }

\manual{unsigned long getStackTopAddr()}{
	Returns the base address for this thread’s stack. 
}

\manual{bool isDeadOnArrival()}{
This function returns \true if this thread terminated execution before Dyninst was able to attach to it.  Since Dyninst performs new thread detection asynchronously, it is possible for a thread to be created and destroyed before Dyninst can attach to it.  When this happens, a new \BPatchthread is created, but \texttt{isDeadOnArrival} always returns \true for this thread.  It is illegal to perform any thread-level operations on a dead on arrival thread.}


\manual{BPatch\_process *getProcess()}{
Return the \BPatchprocess that contains this thread.}

\manual{void *oneTimeCode(const BPatch\_snippet \&expr, bool *err = NULL) }{
Cause the snippet \expr to be evaluated by the process immediately. This is similar to the \texttt{BPatch\_process::oneTimeCode} function, except that the snippet is guaranteed to run only on this thread. The process must be stopped to call this function.  The behavior is synchronous; \texttt{oneTimeCode} will not return until after the snippet has been run in the application.}

\manual{bool oneTimeCodeAsync(const BPatch\_snippet \&expr, 
  void *userData = NULL,
  BpatchOneTimeCodeCallback cb = NULL) }{
This function sets up the snippet expr to be evaluated by this thread at the next available opportunity. When the snippet finishes running, Dyninst will callback any function registered through \texttt{BPatch::registerOneTimeCodeCallback}, with userData passed as a parameter.  This function returns true if \expr was posted or false otherwise.\\

This is similar to the \texttt{BPatch\_process::oneTimeCodeAsync} function, except that the snippet is guaranteed to run only on this thread. The process must be stopped to call this function.  The behavior is asynchronous; \texttt{oneTimeCodeAsync} returns before the snippet is executed.
}


\subsection{CLASS BPATCH\_BINARYEDIT}

The \textbf{\emph{BPatch\_binaryEdit}} class represents a set of executable files and library files for binary rewriting.  \BPatchbinaryEdit inherits from the \BPatchaddressSpace class, where most functionality for binary rewriting is found.

\manual{bool writeFile(const char *outFile)}{
Rewrite a \BPatchbinaryEdit to disk.  The original file opened with this \BPatchbinaryEdit is written to the current working directory with the name outFile.  If any dependent libraries were also opened and have instrumentation or other modifications, then those libraries will be written to disk in the current working directory under their original names.\\
 
A rewritten dependency library should only be used with the original file that was opened for rewriting.  For example, if the file a.out and its dependent library libfoo.so were opened for rewriting, and both had instrumentation inserted, then the rewritten libfoo.so should not be used without the rewritten a.out.  To build a rewritten libfoo.so that can load into any process, libfoo.so must be the original file opened by BPatch::openBinary.\\

This function returns \true if it successfully wrote a file, or \false otherwise.
}


\subsection{CLASS BPATCH\_SOURCEOBJ}\label{sec:bpatch_sourceobj}
\newcommand{\BPatchsourceObj}[0]{\texttt{BPatch\_sourceObj}\xspace}

The \textbf{\emph{BPatch\_sourceObj}} class is the C++ superclass for the \BPatchfunction, \BPatchmodule, and \BPatchimage classes.  It provides a set of common methods for all three classes.  In addition, it can be used to build a “generic” source navigator using the getObjParent and \texttt{getSourceObj} methods to get parents and children of a given level (i.e. the parent of a module is an image, and the children will be the functions).


\manual{
enum BPatchErrorLevel \{ \\
\indent BPatchFatal, BPatchSerious, BPatchWarning, BPatchInfo \};\\\\
enum BPatch\_sourceType \{ \\
\indent BPatch\_sourceUnknown, \\
\indent BPatch\_sourceProgram,\\
\indent BPatch\_sourceModule, \\
\indent BPatch\_sourceFunction, \\
\indent BPatch\_sourceOuterLoop, \\
\indent BPatch\_sourceLoop, \\
\indent BPatch\_sourceStatement \};\\\\
BPatch\_sourceType getSrcType()}{
Returns the type of the current source object.
}

\newcommand{\BPatchsourceProgram}[0]{\texttt{BPatch\_sourceProgram}\xspace}
\newcommand{\BPatchsourceFunction}[0]{\texttt{BPatch\_sourceFunction}\xspace}
\newcommand{\BPatchsourceOuterLoop}[0]{\texttt{BPatch\_sourceOuterLoop}\xspace}
\newcommand{\BPatchsourceStatement}[0]{\texttt{BPatch\_sourceStatement}\xspace}

\manual{void getSourceObj(std::vector<BPatch\_sourceObj *> \&objs)}{
Returns the child source objects of the current source object.  For example, when called on a \BPatchsourceProgram object this will return objects of type \BPatchsourceFunction.  When called on a \BPatchsourceFunction object it may return \BPatchsourceOuterLoop and \BPatchsourceStatement objects.}

\manual{
BPatch\_sourceObj *getObjParent()}{
Return the parent source object of the current source object.  The parent of a \BPatchimage is \NULL.
}

\manual{
typedef enum BPatch\_language \{\\
\indent    BPatch\_c, \\
\indent     BPatch\_cPlusPlus, \\
\indent     BPatch\_fortran, \\
\indent     BPatch\_fortran77, \\
\indent     BPatch\_fortran90,\\
\indent     BPatch\_f90\_demangled\_stabstr, \\
\indent     BPatch\_fortran95,\\
\indent     BPatch\_assembly, \\
\indent     BPatch\_mixed, \\
\indent     BPatch\_hpf, \\
\indent     BPatch\_java, \\
\indent     BPatch\_unknownLanguage \\
\} BPatch\_language;\\\\BPatch\_language getLanguage() 
}{
Return the source language of the current \texttt{BPatch\_sourceObject}.  For programs that are written in more than one language, \texttt{BPatch\_mixed} will be returned.  If there is insufficient information to determine the language, \texttt{BPatch\_unknownLanguage} will be returned.
}


\subsection{CLASS BPATCH\_FUNCTION}

An object of this class represents a function in the application.  A \BPatchimage object (see description below) can be used to retrieve a \BPatchfunction object representing a given function.

\manual{std::string getName();
std::string getDemangledName();\\
std::string getMangledName();\\
std::string getTypedName();\\
void getNames(std::vector<std::string> \&names);\\
void getDemangledNames(std::vector<std::string> \&names);\\
void getMangledNames(std::vector<std::string> \&names);\\
void getTypedNames(std::vector<std::string> \&names);\\
}{
Return name(s) of the function. The \texttt{getName} functions return the primary name; this is typically the first symbol we encounter while parsing the program; \texttt{getName} is an alias for \texttt{getDemangledName}. The \texttt{getNames} functions return all known names for the function, including any names specified by weak symbols. 
}

\manual{bool getAddressRange(Dyninst::Address \&start,
				Dyninst::Address \&end)}{
Returns the bounds of the function; for non-contiguous functions, this is the lowest and highest address of code that the function includes.
}
\newcommand{\BPatchlocalVar}[0]{\texttt{BPatch\_localVar}\xspace}
\manual{
std::vector<BPatch\_localVar *> *getParams()}{
Return a vector of \BPatchlocalVar snippets that refer to the parameters of this function.  The position in the vector corresponds to the position in the parameter list (starting from zero).  The returned local variables can be used to check the types of functions, and can be used in snippet expressions.
}

\manual{
BPatch\_type *getReturnType()}{
Return the type of the return value for this function.
}

\manual{
BPatch\_variableExpr *getFunctionRef()
}{
For platforms with complex function pointers (e.g., 64-bit PPC) this constructs and returns the appropriate descriptor.
}

\manual{
std::vector<BPatch\_localVar *> *getVars()}{
Returns a vector of \BPatchlocalVar objects that contain the local variables in this function.  These \BPatchlocalVar s can be used as parts of snippets in instrumentation.  This function requires debug information to be present in the mutatee.  If Dyninst was unable to find any local variables, this function will return an empty vector.  It is up to the user to free the vector returned by this function.
}

\manual{
bool isInstrumentable()
}{
Return \true if the function can be instrumented, and \false if it cannot.  Various conditions can cause a function to be uninstrumentable.  For example, there exists a platform-specific minimum function size beyond which a function cannot be instrumented.
}

\manual{
bool isSharedLib()
}{
This function returns \true if the function is defined in a shared library.
}

\manual{
BPatch\_module *getModule()}{
Return the module that contains this function.  Depending on whether the program was compiled for debugging or the symbol table stripped, this information may not be available.  This function returns \NULL if module information was not found.
}

\manual{
char *getModuleName(char *name, int maxLen)
}{
Copies the name of the module that contains this function into the buffer pointed to by \texttt{name}.  Copies at most \texttt{maxLen} characters and returns a pointer to name.}

\newcommand{\BPatchsubroutine}[0]{\texttt{BPatch\_subroutine}\xspace}
\newcommand{\BPatchexit}[0]{\texttt{BPatch\_exit}\xspace}
\newcommand{\BPatchentry}[0]{\texttt{BPatch\_entry}\xspace}

\manual{
enum BPatch\_procedureLocation \{ \\
\indent BPatch\_entry,\\ 
\indent BPatch\_exit, 	\\
\indent BPatch\_subroutine,\\ 
\indent BPatch\_locInstruction,\\
\indent BPatch\_locBasicBlockEntry,\\
\indent BPatch\_locLoopEntry,\\
\indent BPatch\_locLoopExit,\\
\indent BPatch\_locLoopStartIter,\\
\indent BPatch\_locLoopStartExit,\\
\indent BPatch\_allLocations \}\\\\
const std::vector<BPatch\_point *> *findPoint(\\
\indent const BPatch\_procedureLocation loc)
}{
Return the \BPatchpoint or list of \BPatchpoint s associated with the procedure. It is used to select which type of points associated with the procedure will be returned. \BPatchentry and \BPatchexit request respectively the entry and exit points of the sub-routine. \BPatchsubroutine returns the list of points where the procedure calls other procedures. If the lookup fails to locate any points of the requested type, \NULL is returned.
}


\newcommand{\BPatchopLoad}[0]{\texttt{BPatch\_opLoad}\xspace}
\newcommand{\BPatchopPrefetch}[0]{\texttt{BPatch\_opPrefetch}\xspace}
\newcommand{\BPatchopStore}[0]{\texttt{BPatch\_opStore}\xspace}
\newcommand{\BPatchopCode}[0]{\texttt{BPatch\_opCode}\xspace}

\manual{
enum BPatch\_opCode \{ BPatch\_opLoad, BPatch\_opStore, BPatch\_opPrefetch \}\\
std::vector<BPatch\_point *> *findPoint(const std::set<BPatch\_opCode>\& ops)\\
std::vector<BPatch\_point *> *findPoint(const BPatch\_Set<BPatch\_opCode>\& ops)
}{
Return the vector of \BPatchpoint s corresponding to the set of machine instruction types described by the argument. This version is used primarily for memory access instrumentation. The \BPatchopCode is an enumeration of instruction types that may be requested: \BPatchopLoad, \BPatchopStore, and \BPatchopPrefetch. Any combination of these may be requested by passing an appropriate argument set containing the desired types. The instrumentation points created by this function have additional memory access information attached to them. This allows such points to be used for memory access specific snippets (e.g. effective address). The memory access information attached is described under Memory Access classes in section~\ref{sec:bpatch_memoryaccess}.
}


\manual{
BPatch\_localVar *findLocalVar(const char *name)
}{
Search the function’s local variable collection for \texttt{name}.  This returns a pointer to the local variable if a match is found.  This function returns \NULL if it fails to find any variables.
}

\manual{
std::vector<BPatch\_variableExpr *> *findVariable(const char * name)\\
bool findVariable(const char *name, std::vector<BPatch\_variableExpr> \&vars)\\
}{
Return a set of variables matching name at the scope of this function.  If no variables match in the local scope, then the global scope will be searched for matches.  This function returns \NULL if it fails to find any variables.
}


\manual{
BPatch\_localVar *findLocalParam(const char *name)}{
Search the function’s parameters for a given name.  A \BPatchlocalVar * pointer is returned if a match is found, and \NULL is returned otherwise.
}

\manual{void *getBaseAddr()}{
Return the starting address of the function in the mutatee’s address space.}

\manual{
BPatch\_flowGraph *getCFG() }{
Return the control flow graph for the function, or \NULL if this information is not available.  The \BPatchflowGraph is described in section~\ref{sec:bpatch_flowgraph}
}


\manual{bool findOverlapping(std::vector<BPatch\_function *> \&funcs) }{
Determine which functions overlap with the current function (see Section~\ref{sec:abstraction}). Return \true if other functions overlap the current function; the overlapping functions are added to the \texttt{funcs} vector. Return \false if no other functions overlap the current function.}


\manual{bool addMods(std::set<StackMod *> mods) \\
\indent implemented on x86 and x86-64}{
Apply stack modifications in \texttt{mods} to the current function; the \texttt{StackMod} class is described in section~\ref{sec:bpatch_stackmod}. Perform error checking, handle stack alignment requirements, and generate any modifications required for cleanup at function exit. \texttt{addMods} atomically adds all modifications in \texttt{mod}s; if any \texttt{mod} is found to be unsafe, none of the modifications in mods will be applied.\\

\texttt{addMods} can only be used in binary rewriting mode.\\

Returns \false if the stack modifications are unsafe or if Dyninst is unable to perform the analysis required to guarantee safety.
}



\subsection{CLASS BPATCH\_POINT}

An object of this class represents a location in an application’s code at which the library can insert instrumentation.  A \BPatchimage object (see section 4.10) is used to retrieve a \BPatchpoint representing a desired point in the application.




\newcommand{\ttt}[1]{\texttt{#1}}
\manual{
enum BPatch_procedureLocation \{ \\ \indent  BPatch_entry, BPatch_exit, 	BPatch_subroutine,BPatch_address\}\\
BPatch_procedureLocation getPointType() }
{Return the type of the point.}

\manual{BPatch_function *getCalledFunction()}{
Return a \BPatchfunction representing the function that is called at the point.  If the point is not a function call site or the target of the call cannot be determined, then this function returns \NULL.
}

\manual{std::string getCalledFunctionName()}{
Returns the name of the function called at this point.  This method is similar to \\\ttt{getCalledFunction()->getName()}, except in cases where DyninstAPI is running in binary rewriting mode and the called function resides in a library or object file that DyninstAPI has not opened.  In these cases, Dyninst is able to determine the name of the called function, but is unable to construct a \BPatchfunction object.
}

\manual{BPatch\_function *getFunction()}{
Returns a \BPatchfunction representing the function in which this point is contained.
}

\newcommand{\BPatchbasicBlockLoop}[0]{\ttt{BPatchbasicBlockLoop}\xspace}

\manual{BPatch_basicBlockLoop *getLoop()}{
Returns the containing \BPatchbasicBlockLoop if this point is part of loop instrumentation.  Returns \NULL otherwise.}


\manual{void *getAddress()}{
Return the address of the first instruction at this point.
}

\manual{bool usesTrap_NP()}{
Return \true if inserting instrumentation at this point requires using a trap.  On the x86 architecture, because instructions are of variable size, the instruction at a point may be too small for Dyninst to replace it with the normal code sequence used to call instrumentation.  Also, when instrumentation is placed at points other than subroutine entry, exit, or call points, traps may be used to ensure the instrumentation fits. In this case, Dyninst replaces the instruction with a single-byte instruction that generates a trap.  A trap handler then calls the appropriate instrumentation code.  Since this technique is used only on some platforms, on other platforms this function always returns \false.}

\manual{const BPatch_memoryAccess* getMemoryAccess()}{
Returns the memory access object associated with this point.  Memory access points are described in section~\ref{sec:bpatch_memoryaccess}}

\newcommand{\BPatchcallBefore}[0]{\texttt{BPatch_callBefore}\xspace}
\newcommand{\BPatchcallAfter}[0]{\texttt{BPatch_callAfter}\xspace}

\manual{const std::vector<BPatchSnippetHandle *> getCurrentSnippets()\\
const std::vector<BPatchSnippetHandle *>\\ 
\indent     getCurrentSnippets(BPatch_callWhen when)}{
Return the \BPatchSnippetHandle s for the \BPatchsnippet s that are associated with the point.  If argument when is \BPatchcallBefore, then \BPatchSnippetHandle s for snippets installed immediately before this point will be returned.  Alternatively, if when is \BPatchcallAfter, then \BPatchSnippetHandle s for snippets installed immediately after this point will be returned.}

\manual{bool getLiveRegisters(std::vector<BPatch_register> &regs) }{
Fill \ttt{regs} with the registers that are live before this point (e.g., \BPatchcallBefore). Currently returns only general purpose registers (GPRs).}

\manual{bool isDynamic()}{
This call returns true if this is a dynamic call site (e.g. a call site where the function call is made via a function pointer).}


\manual{void* monitorCalls(BPatch_function* func)}{
For a dynamic call site, this call instruments the call site represented by this instrumentation point with a function call. If input parameter func is not \NULL, \texttt{func} is called at the call site as the instrumentation. If \texttt{func} is NULL, the callback function registered with \ttt{BPatch::registerDynamicCallCallback} is used for instrumentation. Under both cases, this call returns a pointer to the called function. If the instrumentation point does not represent a dynamic call site, this call returns \NULL.}

\manual{bool stopMonitoring()}{
This call returns \true if this instrumentation point is a dynamic call site and its instrumentation is successfully removed. Otherwise, it returns \false.
}
\manual{Dyninst::InstructionAPI::Instruction::Ptr getInstructionAtPoint()}{
On implemented platforms, this function returns a shared pointer to an InstructionAPI Instruction object representing the first machine instruction at this point’s address.  On unimplemented platforms, returns a \NULL shared pointer.}


\subsection{CLASS BPATCH\_IMAGE}

This class defines a program image (the executable associated with a process).  The only way to get a handle to a \BPatchimage is via the \BPatchprocess member function \ttt{getImage}.

\manual{const BPatch_point *createInstPointAtAddr (caddr_t address)}
{This function has been removed because it is not safe to use. Instead, use findPoints:}

\manual{bool findPoints(Dyninst::Address addr, 
std::vector<BPatch_point *> &points);}{
Returns a vector of \BPatchpoint s that correspond with the provided address, one per function that includes an instruction at that address. There will be one element if there is not overlapping code.}

\manual{std::vector<BPatch_variableExpr *> *getGlobalVariables()}{
Return a vector of global variables that are defined in this image.}

\manual{BPatch_process *getProcess()}{
Returns the \BPatchprocess associated with this image.}

\manual{char *getProgramFileName(char *name, unsigned int len)}{
Fills provided buffer \ttt{name} with the program’s file name up to \ttt{len} characters.  The filename may include path information.}


\manual{bool getSourceObj(std::vector<BPatch_sourceObj *> &sources)}{
Fill \ttt{sources} with the source objects (see section~\ref{sec:bpatch_sourceobj}) that belong to this image.  If there are no source objects, the function returns \false.  Otherwise, it returns \true.}

\manual{std::vector<BPatch_function *> *getProcedures(
bool incUninstrumentable = false)}{
Return a vector of the functions in the image. If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include uninstrumentable functions. The default behavior is to omit these functions.
}

\manual{void getObjects(std::vector<BPatch_object *> &objs)}{
Fill in a vector of objects in the image. }


\manual{std::vector<BPatch_module *> *getModules()}{
Return a vector of the modules in the image.}

\manual{bool getVariables(std::vector<BPatch_variableExpr *> &vars)}{
Fills \ttt{vars} with the global variables defined in this image.  If there are no variable, the function returns \false.  Otherwise, it returns \true.}

\manual{std::vector<BPatch_function*> *findFunction(\\
const char *name,\\
std::vector<BPatch_function*> &funcs,\\
bool showError = true,\\
bool regex_case_sensitive = true,\\
bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s corresponding to name, or \NULL if the function does not exist.  If \texttt{name} contains a POSIX-extended regular expression, and \ttt{dont_use_regex} is false, a regular expression search will be performed on function names and matching \BPatchfunction s returned.  If \ttt{showError} is true, then Dyninst will report an error via the \ttt{BPatch::registerErrorCallback} if no function is found.\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include uninstrumentable functions. The default behavior is to omit these functions.\\

[NOTE: If \ttt{name} is not found to match any demangled function names in the module, the search is repeated as if \ttt{name} is a mangled function name.  If this second search succeeds, functions with mangled names matching name are returned instead.]
}

\manual{std::vector<BPatch_function*> *findFunction(\\
std::vector<BPatch_function*> &funcs,\\
BPatchFunctionNameSieve bpsieve,\\
void *sieve_data = NULL,\\
int showError = 0,\\
bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s according to the generalized user-specified filter function \ttt{bpsieve}.  This permits users to easily build sets of functions according to their own specific criteria.  Internally, for each \BPatchfunction f in the image, this method makes a call to \ttt{bpsieve(f.getName(), sieve_data)}.  The user-specified function \ttt{bpsieve} is responsible for taking the \ttt{name} argument and determining if it belongs in the output vector, possibly by using extra user-provided information stored in \ttt{sieve_data}.  If the name argument matches the desired criteria, \ttt{bpsieve} should return \true.  If it does not, \ttt{bpsieve} should return {false}.\\

The function bpsieve should be defined in accordance with the typedef:\\

\ttt{bool (*BPatchFunctionNameSieve) (const char *name, void* sieve_data);}\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include uninstrumentable functions. The default behavior is to omit these functions.
}


\manual{bool findFunction(Dyninst::Address addr, std::vector<BPatch_function *> &funcs)}{
Find all functions that have code at the given address, \addr.  Dyninst supports functions that share code, so this method may return more than one \BPatchfunction.  These functions are returned via the \ttt{funcs} output parameter.  This function returns \true if it finds any functions, \false otherwise.
}

\newcommand{\BPatchvariableExpr}[0]{\ttt{BPatch_variableExpr}\xspace}

\manual{BPatch_variableExpr *findVariable(const char *name, \\
\indent     bool showError = true)\\
BPatch_variableExpr *findVariable(BPatch_point &scope, \\
\indent  const char *name) second form of this method is not implemented on Windows.}{
Performs a lookup and returns a handle to the named variable.  The first form of the function looks up only variables of global scope, and the second form uses the passed \BPatchpoint as the scope of the variable. The returned \BPatchvariableExpr can be used to create references (uses) of the variable in subsequent snippets. The scoping rules used will be those of the source language. If the image was not compiled with debugging symbols, this function will fail even if the variable is defined in the passed scope. }

\manual{BPatch_type *findType(const char *name) }{
Performs a lookup and returns a handle to the named type. The handle can be used as an argument to \ttt{BPatch_addressSpace::malloc} to create new variables of the corresponding type.  }

\manual{BPatch_module *findModule(const char *name,\\
\indent bool substring_match = false)}{
Returns a module named \ttt{name} if present in the image.  If the match fails, \NULL is returned.  If \ttt{substring_match} is true, the first module that has name as a substring of its name is returned (e.g. to find \ttt{libpthread.so.1}, search for \ttt{libpthread} with \ttt{substring_match} set to true).}

\manual{bool getSourceLines(unsigned long addr, \\
\indent     std::vector<BPatch_statement> & lines) }{
Given an address \ttt{addr}, this function returns a vector of pairs of filenames and line numbers at that address.  This function is an alias for \ttt{BPatch_process::getSourceLines} (see section~\ref{sec:bpatch_process}).  }

\manual{bool getAddressRanges( const char * fileName, unsigned int lineNo, std::vector<\\ \indent std::pair< unsigned long, unsigned long > > & ranges ) }{
Given a file name and line number, \ttt{fileName} and \ttt{lineNo}, this function returns a list of address ranges that this source line was compiled into.  This function is an alias for \ttt{BPatch_process::getAddressRanges} (see section~\ref{sec:bpatch_proces}).}

\manual{bool parseNewFunctions(std::vector<BPatch_module*> &newModules, const\\ 
\indent std::vector<Dyninst::Address> &funcEntryAddrs) }{
This function takes as input a list of function entry points indicated by the \ttt{funcEntryAddrs} vector, which are used to seed parsing in whatever modules they are found.  All affected modules are placed in the \ttt{newModules} vector, which includes any existing modules in which new functions are found, as well as modules corresponding to new regions of the binary, for which new \BPatchmodule s are created.  The return value is \true in the event that at least one previously unknown function was identified, or \false otherwise.  
}



\subsection{CLASS BPATCH\_OBJECT}

An object of this class represents the original executable or a library. It serves as a container of \ttt{BPatch_module} objects.

\manual{std::string name()\\
std::string pathName()}{
Return the name of this file; either just the file name or the fully path-qualified name. }

\manual{Dyninst::Address fileOffsetToAddr(Dyninst::Offset offset)}{
Convert the provided offset into the file into a full address in memory. }

\manual{
struct Region {\\
\indent	typedef enum \{ UNKNOWN, CODE, DATA \} type_t;\\
\indent	Dyninst::Address base;\\
\indent	unsigned long size;\\
\indent	type_t type;
};\\
void regions(std::vector<Region> &regions)}{
Returns information about the address ranges occupied by this object in memory. 
}

\manual{void modules(std::vector<BPatch_module *> &modules)}{
Returns the modules contained in this object.}

\manual{std::vector<BPatch_function*> *findFunction(\\
\indent const char *name,\\
\indent std::vector<BPatch_function*> &funcs,\\
\indent bool showError = true,\\
\indent bool regex_case_sensitive = true,\\
\indent bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s corresponding to \ttt{name}, or \NULL if the function does not exist.  If name contains a POSIX-extended regular expression, and \ttt{dont_use_regex} is \false, a regular expression search will be performed on function names and matching \BPatchfunction s returned.  If \ttt{showError} is true, then Dyninst will report an error via the \ttt{BPatch::registerErrorCallback} if no function is found.\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include un-instrumentable functions. The default behavior is to omit these functions.\\

[NOTE: If \ttt{name} is not found to match any demangled function names in the module, the search is repeated as if \ttt{name} is a mangled function name.  If this second search succeeds, functions with mangled names matching name are returned instead.]}


\manual{bool findPoints(Dyninst::Address addr, \\
\indent std::vector<BPatch_point *> &points);\\}{
Return a vector of \BPatchpoint s that correspond with the provided address, one per function that includes an instruction at that address. There will be one element if there is not overlapping code.}

\newcommand{\BPatchobject}[0]{\ttt{BPatch_object}\xspace}

\manual{std::vector<BPatch_function*> *findFunction(\\
\indent const char *name,\\
\indent std::vector<BPatch_function*> &funcs,\\
\indent bool notify_on_failure = true,\\
\indent bool regex_case_sensitive = true,\\
\indent bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s matching \ttt{name}, or \NULL if the function does not exist.  If name contains a POSIX-extended regular expression, a regex search will be per-formed on function names, and matching \BPatchfunction s returned. [NOTE: The std::vector argument funcs must be declared fully by the user before calling this function.  Passing in an uninitialized reference will result in undefined behavior.]\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include un-instrumentable functions. The default behavior is to omit these functions.\\

[NOTE: If \ttt{name} is not found to match any demangled function names in the \BPatchobject, the search is repeated as if \ttt{name} is a mangled function name.  If this second search succeeds, functions with mangled names matching name are returned instead.]
}

\subsection{CLASS BPATCH\_MODULE}


An object of this class represents a program module, which is part of a program’s executable image. A \BPatchmodule represents a source file in either an executable or a shared library.  Dyninst automatically creates a module called DEFAULT_MODULE in each executable to hold any objects that it cannot match to a source file. \BPatchmodule objects are obtained by calling the \BPatchimage member function \ttt{getModules}.

\manual{std::vector<BPatch_function*> *findFunction(\\
\indent const char *name,\\
\indent std::vector<BPatch_function*> &funcs,\\
\indent bool notify_on_failure = true,\\
\indent bool regex_case_sensitive = true,\\
\indent bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s matching \ttt{name}, or \NULL if the function does not exist.  If name contains a POSIX-extended regular expression, a regex search will be performed on function names, and matching \BPatchfunction s returned. [NOTE: The std::vector argument \ttt{funcs} must be declared fully by the user before calling this function.  Passing in an uninitialized reference will result in undefined behavior.]\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include un-instrumentable functions. The default behavior is to omit these functions.\\

[NOTE: If \ttt{name} is not found to match any demangled function names in the module, the search is repeated as if \ttt{name} is a mangled function name.  If this second search succeeds, functions with mangled names matching name are returned instead.]}

\manual{BPatch_Vector<BPatch_function *> *findFunctionByAddress(\\
\indent void *addr,\\
\indent BPatch_Vector<BPatch_function *> &funcs,\\
\indent bool notify_on_failure = true,\\
\indent bool incUninstrumentable = false)}{
Return a vector of \BPatchfunction s that contains \ttt{addr}, or \NULL if the function does not exist.  [NOTE: The std::vector argument \ttt{funcs} must be declared fully by the user before calling this function.  Passing in an uninitialized reference will result in undefined be-havior.]\\

If the \ttt{incUninstrumentable} flag is set, the returned table of procedures will include un-instrumentable functions. The default behavior is to omit these functions.
}

\manual{BPatch_function *findFunctionByEntry(Dyninst::Address addr)\\
\indent Returns the function that begins at the specified address addr.\\
\indent BPatch_function *findFunctionByMangled(\\
\indent const char *mangled_name,\\
\indent bool incUninstrumentable = false)}{
Return a \BPatchfunction for the mangled function name defined in the module corresponding to the invoking \BPatchmodule, or \NULL if it does not define the function.  \\

If the \ttt{incUninstrumentable} flag is set, the functions searched will include un-instrumentable functions. The default behavior is to omit these functions.}


\manual{bool getAddressRanges( char * fileName, unsigned int lineNo, \\
\indent std::vector< std::pair< unsigned long, unsigned long > > & ranges )}{
Given a filename and line number, \ttt{fileName} and \ttt{lineNo}, this function returns the ranges of mutatee addresses that implement the code range in the output parameter ranges.  In many cases a source code line will only have one address range implementing it.  However, compiler optimizations may turn this into multiple, disjoint address ranges.  This information is only available if the mutatee was compiled with debug information.\\

This function may be more efficient than the \BPatchprocess version of this function.  Calling \ttt{BPatch_process::getAddressRange} will cause Dyninst to parse line information for all modules in a process.  If \ttt{BPatch_module::getAddressRange} is called then only the debug information in this module will be parsed.\\

This function returns \true if it was able to find any line information, \false otherwise.}

\manual{size_t getAddressWidth()}{
Return the size (in bytes) of a pointer in this module.  On 32-bit systems this function will return 4, and on 64-bit systems this function will return 8.}

\manual{void *getBaseAddr()}{
Return the base address of the module.  This address is defined as the start of the first function in the module.}

\manual{std::vector<BPatch_function *> \\
\indent *getProcedures( bool incUninstrumentable = false )}{
Return a vector containing the functions in the module. }

\manual{char *getFullName(char *buffer, int length)}{
Fills \ttt{buffer} with the full path name of a module, up to length characters when this information is available.}

\manual{BPatch_hybridMode getHybridMode()}{
Return the mutator’s analysis mode for the mutatee; the default mode is the normal mode.}

\manual{char *getName(char *buffer, int len)}{
This function copies the filename of the module into \ttt{buffer}, up to \ttt{len} characters.  It returns the value of the \ttt{buffer} parameter.}

\manual{unsigned long getSize()}{
Return the size of the module.  The size is defined as the end of the last function minus the start of the first function.}

\manual{bool getSourceLines( unsigned long addr, std::vector<BPatch_statement> & lines )}{
This function returns the line information associated with the mutatee address \addr.  The vector \ttt{lines} contain pairs of filenames and line numbers that are associated with \addr.  In many cases only one filename and line number is associated with an address, but certain compiler optimizations may lead to multiple filenames and lines at an address.    This information is only available if the mutatee was compiled with debug information.\\

This function may be more efficient than the \BPatchprocess version of this function.  Calling \BPatchprocess::getSourceLines will cause Dyninst to parse line information for all modules in a process.  If \ttt{BPatch_module::getSourceLines} is called then only the debug information in this module will be parsed.\\

This function returns \true if it was able to find any line information at \addr, or \false otherwise.}


\manual{char *getUniqueString(char *buffer, int length)}{
Performs a lookup and returns a unique string for this image. Returns a string the can be compared (via \ttt{strcmp}) to indicate if two images refer to the same underlying object file (i.e., executable or library).  The contents of the string are implementation specific and defined to have no semantic meaning.}

\manual{bool getVariables(std::vector<BPatch_variableExpr *> &vars)}{
Fill the vector \ttt{vars} with the global variables that are specified in this module.  Returns \false if no results are found and \true otherwise.}

\manual{BpatchSnippetHandle* insertInitCallback(Bpatch_snippet& callback) }{
This function inserts the snippet \ttt{callback} at the entry point of this module’s \ttt{init} function (creating a new init function/section if necessary).}

\manual{BpatchSnippetHandle* insertFiniCallback(Bpatch_snippet& callback) }{
This function inserts the snippet \ttt{callback} at the exit point of this module’s fini function (creating a new fini function/section if necessary).}

\manual{bool isExploratoryModeOn() }{
This function returns \true if the mutator’s analysis mode sets to the defensive mode or the exploratory mode.}

\manual{bool isMutatee() }{
This function returns \true if the module is the mutatee.}

\manual{bool isSharedLib() }{
This function returns \true if the module is part of a shared library.}










\subsection{CLASS BPATCH\_SNIPPET}
\subsection{CLASS BPATCH\_TYPE}
\subsection{CLASS BPATCH\_VARIABLEEXPR}
\subsection{CLASS BPATCH\_FLOWGRAPH}\label{sec:bpatch_flowgraph}
\subsection{CLASS BPATCH\_BASICBLOCK}
\subsection{CLASS BPATCH\_EDGE}
\subsection{CLASS BPATCH\_BASICBLOCKLOOP}
\subsection{CLASS BPATCH\_LOOPTREENODE}
\subsection{CLASS BPATCH\_REGISTER}
\subsection{CLASS BPATCH\_SOURCEBLOCK}
\subsection{CLASS BPATCH\_CBLOCK}\label{sec:bpatch_cblock}
\subsection{CLASS BPATCH\_FRAME}\label{sec:bpatch_frame}
\subsection{CLASS STACKMOD}\label{sec:bpatch_stackmod}

\subsection{CONTAINER CLASSES}
\subsubsection{Class std::vecotr}
\subsubsection{Class BPatch\_Set}

\subsection{MEMORY ACCESS CLASSES}
\subsubsection{Class BPatch\_memoryAccess}\label{sec:bpatch_memoryaccess}
\subsubsection{Class BPatch\_addrSpec\_NP}
\subsubsection{Class BPatch\_countSpec\_NP}
\subsection{TYPE SYSTEM}\label{sec:type_system}

\pagebreak
