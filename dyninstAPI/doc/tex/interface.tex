\section{Interface}
This section describes functions in the API.  The API is organized as a collection of C++ classes. The primary classes are \BPatch, \BPatchprocess, \BPatchbinaryEdit, \BPatchthread, \BPatchimage, \BPatchpoint, and \BPatchsnippet. The API also uses a template class called std::vector.  This class is based on the Standard Template Library (STL) vector class. 

\newenvironment{myenv}{\begin{adjustwidth}{1cm}{}}{\end{adjustwidth}}
\newcommand{\manual}[2]{\mbox{}\code{#1}
\begin{myenv}
#2	
\end{myenv}
}
\newcommand{\BPatchexploratoryMode}[0]{\texttt{BPatch\_exploratoryMode}\xspace}
\newcommand{\BPatchnormalMode}[0]{\texttt{BPatch\_normalMode}\xspace}
\newcommand{\BPatchdefensiveMode}[0]{\texttt{BPatch\_defensiveMode}\xspace}
\subsection{CLASS BPatch}

The BPatch class represents the entire Dyninst library.  There can only be one instance of this class at a time.  This class is used to perform functions and obtain information that is not specific to a particular thread or image.

\manual{std::vector<BPatch\_process*> *getProcesses()}{
Returns the list of processes that are currently defined.  This list includes processes that were directly created by calling processCreate/processAttach, and indirectly by the UNIX fork or the Windows CreateProcess system call.   It is up to the user to delete this vector when they are done with it.	}

\manual{BPatch\_process *processAttach(const char *path, int pid, BPatch\_hybridMode mode=BPatch\_normalMode)\\
BPatch\_process *processCreate(const char *path, const char *argv[], const char **envp = NULL, int stdin\_fd=0, int stdout\_fd=1, int stderr\_fd=2, BPatch\_hybridMode mode=BPatch\_normalMode)  }{Each of these functions returns a pointer to a new instance of the BPatch\_process class.  The path parameter needed by these functions should be the pathname of the executable file containing the process image. The processAttach function returns a BPatch\_process associated with an existing process.  On Linux platforms the path parameter can be NULL since the executable image can be derived from the process pid.  Attaching to a process puts it into the stopped state.  The processCreate function creates a new process and returns a new BPatch\_process associated with it.  The new process is put into a stopped state be-fore executing any code.\\

The stdin\_fd, stdout\_fd, and stderr\_fd parameters are used to set the standard input, output, and error of the child process.  The default values of these parameters leave the input, output, and error to be the same as the mutator process.  To change these values, an open UNIX file descriptor (see open(1)) can be passed.\\

The \texttt{mode} parameter is used to select the desired level of code analysis.  Activating hybrid code analysis causes Dyninst to augment its static analysis of the code with run-time code discovery techniques. There are three modes:  \BPatchnormalMode, \BPatchexploratoryMode, and \BPatchdefensiveMode. Normal mode enables the regular static analysis features of Dyninst. Exploratory mode and defensive mode enable addtional dynamic features to correctly analyze programs that contain uncommon code patterns, such as malware. Exploratory mode is primarily oriented towards analyzing dynamic control transfers, while defensive mode additionally aims to tackle code obfuscation and self-modifying code. Both of these modes are still experimental and should be used with caution. Defensive mode is only supported on Windows.\\

Defensive mode has been tested on normal binaries (binaries that run correctly under normal mode), as well as some simple, packed executables (self-decrypting or decompressing). More advanced forms of code obfuscation, such as self-modifying code, have not been tested recently. The traditional Dyninst interface may be used for instrumentation of binaries in defensive mode, but in the case of highly obfuscated code, this interface may prove to be ineffective due to the lack of a complete view of control flow at any given point. Therefore, defensive mode also includes a set of callbacks that enables instrumentation to be performed as new code is discovered. Due to the fact that recent efforts have focused on simpler forms of obfuscation, these callbacks have not been tested in detail. The next release of Dyninst will target more advanced uses of defensive mode.
}

\manual{BPatch\_binaryEdit *openBinary(const char *path, 
bool openDependencies = false)}{
This function opens the executable file or library file pointed to by path for binary rewrit-ing.  If \texttt{openDependencies} is true then Dyninst will also open all shared libraries that path depends on.  Upon success, this function returns a new instance of a \BPatchbinaryEdit class that represents the opened file and any dependent shared libraries.  This function re-turns NULL in the event of an error.
}
\newcommand{\false}[0]{\texttt{false}\xspace}
\newcommand{\true}[0]{\texttt{true}\xspace}
\manual{
bool pollForStatusChange()}{
This is useful for a mutator that needs to periodically check on the status of its managed threads and does not want to check each process individually.  It returns true if there has been a change in the status of one or more threads that has not yet been reported by either \texttt{isStopped} or \texttt{isTerminated}.
}

\manual{
void setDebugParsing (bool state)}{
Turn on or off the parsing of debugger information.  By default, the debugger information (produced by the –g compiler option) is parsed on those platforms that support it.  However, for some applications this information can be quite large.  To disable parsing this information, call this method with a value of \false prior to creating a process. 
}

\manual{
bool parseDebugInfo()}{
Return true if debugger information parsing is enabled, or \false otherwise.
}

\manual{
void setTrampRecursive (bool state)}{
Turn on or off trampoline recursion.  By default, any snippets invoked while another snip-pet is active will not be executed.  This is the safest behavior, since recursively-calling snippets can cause a program to take up all available system resources and die.  For example, adding instrumentation code to the start of printf, and then calling printf from that snippet will result in infinite recursion.\\

This protection operates at the granularity of an instrumentation point.  When snippets are first inserted at a point, this flag determines whether code will be created with recursion protection.  Changing the flag is \emph{\textbf{not}} retroactive, and inserting more snippets will not change the recursion protection of the point.  Recursion protection increases the overhead of instrumentation points, so if there is no way for the snippets to call themselves, calling this method with the parameter \true will result in a performance gain.  The default value of this flag is \false.
}

\manual{bool isTrampRecursive ()}{
Return whether trampoline recursion is enabled or not.  \texttt{True} means that it is enabled.
}

\manual{void setTypeChecking(bool state)}{
Turn on or off type-checking of snippets.  By default type-checking is turned on, and an attempt to create a snippet that contains type conflicts will fail.  Any snippet expressions created with type-checking off have the type of their left operand.  Turning type-checking off, creating a snippet, and then turning type-checking back on is similar to the type cast operation in the C programming language. 
}

\manual{
bool isTypeChecked()}{
Return \true if type-checking of snippets is enabled, or \false otherwise.
}

\manual{
bool waitForStatusChange()}{
This function waits until there is a status change to some thread that has not yet been re-ported by either isStopped or isTerminated, and then returns true.  It is more efficient to call this function than to call pollForStatusChange in a loop, because waitFor-StatusChange blocks the mutator process while waiting.
}

\manual{
void setDelayedParsing (bool)}{
Turn on or off delayed parsing. When it is activated Dyninst will initially parse only the symbol table information in any new modules loaded by the program, and will postpone more thorough analysis (instrumentation point analysis, variable analysis, and discovery of new functions in stripped binaries).  This analysis will automatically occur when the infor-mation is necessary.\\

Users which require small run-time perturbation of a program should not delay parsing; the overhead for analysis may occur at unexpected times if it is triggered by internal Dyninst behavior.  Users who desire instrumentation of a small number of functions will benefit from delayed parsing.
}

\manual{
bool delayedParsingOn()}
{
Return \true if delayed parsing is enabled, or \false otherwise.
}


\manual{void setInstrStackFrames(bool)}{
Turn on and off stack frames in instrumentation.  When on, Dyninst will create stack frames around instrumentation.  A stack frame allows Dyninst or other tools to walk a call stack through instrumentation, but introduces overhead to instrumentation.  The default is to not create stack frames.}

\manual{bool getInstrStackFrames()}{
Return \true if instrumentation will create stack frames, or \false otherwise.  }

\manual{void setMergeTramp (bool)}{
Turn on or off inlined tramps.  Setting this value to \true will make each base trampoline have all of its mini-trampolines inlined within it.  Using inlined mini-tramps may allow instrumentation to execute faster, but inserting and removing instrumentation may take more time.  The default setting for this is \true.}

\manual{bool isMergeTramp ()}{
This returns the current status of inlined trampolines.  A value of \true indicates that trampolines are inlined.}

\manual{void setSaveFPR (bool)}{
Turn on or off floating point saves.  Setting this value to false means that floating point registers will never be saved, which can lead to large performance improvements.  The default value is \true.  Setting this flag may cause incorrect program behavior if the instrumentation does clobber floating point registers, so it should only be used when the user is positive this will never happen.}

\manual{bool isSaveFPROn ()}{
This returns the current status of the floating point saves. \texttt{True} means we are saving float-ing points based on the analysis for the given platform.}

\manual{void setBaseTrampDeletion(bool)}{
If \true, we delete the base tramp when the last corresponding minitramp is deleted.  If \false, we leave the base tramp in.  The default value is \false.}

\manual{bool baseTrampDeletion()}{
Return \true if base trampolines are set to be deleted, or \false otherwise.}

\manual{void setLivenessAnalysis(bool)}{
If \true, we perform register liveness analysis around an instPoint before inserting instrumentation, and we only save registers that are live at that point.  This can lead to faster run-time speeds, but at the expense of slower instrumentation time.  The default value is \true.}

\manual{bool livenessAnalysisOn()}{
Return \true if liveness analysis is currently enabled.}

\manual{void getBPatchVersion(int \&major, int \&minor, int \&subminor)}{
Return Dyninst’s version number.  The major version number will be stored in major, the minor version number in minor, and the subminor version in subminor.  For example, under Dyninst 5.1.0, this function will return 5 in major, 1 in minor, and 0 in subminor.}

\manual{int getNotificationFD()}{
Returns a file descriptor that is suitable for inclusion in a call to select(). Dyninst will write data to this file descriptor when it to signal a state change in the process.  \texttt{BPatch::pollForStatusChange} should then be called so that Dyninst can handle the state change.  This is useful for applications where the user does not want to block in \texttt{BPatch::waitForStatusChange}.  The file descriptor will reset when the user calls \texttt{BPatch::pollForStatusChange}.}

\manual{BPatch\_type *createArray(const char *name, BPatch\_type *ptr, unsigned int low, unsigned int hi) }{
Create a new array type.  The name of the type is name, and the type of each element is ptr.  The index of the first element of the array is low, and the last is high.  The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with arrays created using this function.}

\manual{BPatch\_type *createEnum(const char *name, std::vector<char *> \&elementNames, std::vector<int> \&elementIds) \\
BPatch\_type *createEnum(const char *name, std::vector<char *> \&elementNames)}{
Create a new enumerated type. There are two variations of this function.  The first one is used to create an enumerated type where the user specifies the identifier (int) for each element.  In the second form, the system specifies the identifiers for each element.  In both cases, a vector of character arrays is passed to supply the names of the elements of the enumerated type.  In the first form of the function, the number of element in the element-Names and elementIds vectors must be the same, or the type will not be created and this function will return NULL. The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with enums created using this function.}

\manual{BPatch\_type *createScalar(const char *name, int size) }{
Create a new scalar type.  The name field is used to specify the name of the type, and the size parameter is used to specify the size in bytes of each instance of the type.  No additional information about this type is supplied.  The type is compatible with other scalars with the same name and size.}

\manual{BPatch\_type *createStruct(const char *name, std::vector<char *> \&fieldNames, std::vector<BPatch\_type *> \&fieldTypes) }{
Create a new structure type.  The name of the structure is specified in the name parameter.  The fieldNames and fieldTypes vectors specify fields of the type.  These two vectors must have the same number of elements or the function will fail (and return NULL). The standard rules of type compatibility, described in Section~\ref{sec:type_system}, are used with structures created using this function. The size of the structure is the sum of the size of the elements in the fieldTypes vector.}

\manual{BPatch\_type *createTypedef(const char *name, BPatch\_type *ptr) }{
Create a new type called name and having the type ptr. }

\manual{BPatch\_type *createPointer(const char *name, BPatch\_type *ptr)\\
BPatch\_type *createPointer(const char *name, BPatch\_type *ptr, int size)}{ 
Create a new type, named name, which points to objects of type ptr. The first form creates a pointer whose size is equal to sizeof(void*)on the target platform where the mutatee is running.  In the second form, the size of the pointer is the value passed in the size parameter.}

\manual{BPatch\_type *createUnion(const char *name, std::vector<char *> \&fieldNames, std::vector<BPatch\_type *> \&fieldTypes) }{
Create a new union type.  The name of the union is specified in the name parameter.  The fieldNames and fieldTypes vectors specify fields of the type.  These two vectors must have the same number of elements or the function will fail (and return NULL). The size of the union is the size of the largest element in the fieldTypes vector.
}


\subsection{Callbacks}

The following functions are intended as a way for API users to be informed when an error or significant event occurs.  Each function allows a user to register a handler for an event.  The return code for all callback registration functions is the address of the handler that was previously registered (which may be NULL if no handler was previously registered).  For backwards compatibility reasons, some callbacks may pass a \BPatchthread object when a \BPatchprocess may be more appropriate.  A \BPatchthread may be converted into a \BPatchprocess using \texttt{BPatch\_thread::getProcess()}.

\subsubsection{Asynchronous Callbacks}


\manual{typedef void (*BPatchAsyncThreadEventCallback)(
BPatch\_process *proc, BPatch\_thread *thread)\\
bool registerThreadEventCallback(BPatch\_asyncEventType type,
BPatchAsyncThreadEventCallback cb)\\
bool removeThreadEventCallback(BPatch\_asyncEventType type,
	BPatch\_AsyncThreadEventCallback cb)
}{
The type parameter can be either one of BPatch\_threadCreateEvent or BPatch\_threadDestroyEvent.  Different callbacks can be registered for different values of type.
}


\subsubsection{Code Discovery Callbacks}

\manual{
typedef void (*BPatchCodeDiscoveryCallback)( BPatch\_Vector<BPatch\_function*> \&newFuncs,                BPatch\_Vector<BPatch\_function*> \&modFuncs)\\
bool registerCodeDiscoveryCallback(BPatchCodeDiscoveryCallback cb)\\
bool removeCodeDiscoveryCallback(BPatchCodeDiscoveryCallback cb)}{
This callback is invoked whenever previously un-analyzed code is discovered through runtime analysis, and delivers a vector of functions whose analysis have been modified and a vector of functions that are newly discovered.}


\subsubsection{Code Overwrite Callbacks}
\manual{
typedef void (*BPatchCodeOverwriteBeginCallback)(\\
\indent BPatch\_Vector<BPatch\_basicBlock*> \&overwriteLoopBlocks);\\
typedef void (*BPatchCodeOverwriteEndCallback)(\\
\indent BPatch\_Vector<std::pair<Dyninst::Address,int> > \&deadBlocks, \\
\indent BPatch\_Vector<BPatch\_function*> \&owFuncs,\\
\indent BPatch\_Vector<BPatch\_function*> \&modFuncs, \\
\indent BPatch\_Vector<BPatch\_function*> \&newFuncs)\\
bool registerCodeOverwriteCallbacks(
\\ 
\indent BPatchCodeOverwriteBeginCallback cbBegin,\\ 
\indent BPatchCodeOverwriteEndCallback cbEnd)}{
Register a callback at the beginning and end of overwrite events.  Only invoke if Dyninst's hybrid analysis mode is set to \BPatchdefensiveMode.\\

The \texttt{BPatchCodeOverwriteBeginCallback} callback allows the user to remove any in-strumentation when the program starts writing to a code page, which may be desirable as instrumentation cannot be removed during the overwrite loop's execution, and any break-point instrumentation will dramatically slow the loop's execution.\\

The \texttt{BPatchCodeOverwriteEndCallback} callback delivers the effects of the overwrite loop when it is done executing.  In many cases no code will have changed.
}
\newcommand{\NULL}[0]{\texttt{NULL}\xspace}

\subsubsection{Dynamic Calls}
\manual{
typedef void (*BPatchDynamicCallSiteCallback)(\\
\indent BPatch\_point *at\_point, BPatch\_function *called\_function);\\
bool registerDynamicCallCallback(BPatchDynamicCallSiteCallback cb);\\
bool removeDynamicCallCallback(BPatchDynamicCallSiteCallback cb);}{
The \texttt{registerDynamicCallCallback} interface will not automatically instrument any dynamic call site. To make sure the call back function is called, the user needs to explicitly in-strument dynamic call sites. One way to achieve this goal is to first get instrumentation points representing dynamic call sites and then call \texttt{BPatch\_point::monitorCalls} with a \NULL input parameter. 
}
\subsubsection{Dynamic Libraries}

\manual{
typedef void (*BPatchDynLibraryCallback)(BPatch\_thread *thr,\\
\indent BPatch\_object *obj, bool loaded);\\
BPatchDynLibraryCallback registerDynLibraryCallback(\\
\indent BPatchDynLibraryCallback func)}{
Note that in versions previous to 9.1, BPatchDynLibraryCallback’s signature took a BPatch\_module instead of a BPatch\_object.
}

\subsubsection{Errors}
\manual{
enum BPatchErrorLevel \{ \\
\indent BPatchFatal, BPatchSerious, BPatchWarning, BPatchInfo \};\\
typedef void (*BPatchErrorCallback)(\\
\indent BPatchErrorLevel severity, int number, const char * const *params)\\
BPatchErrorCallback registerErrorCallback(BPatchErrorCallback func)}{
This function registers the error callback function with the BPatch class.  The return value is the address of the previous error callback function. Dyninst users can change the error callback during program execution (e.g., one error callback before a GUI is initialized, and a different one after). The \texttt{severity} field indicates how important the error is (from fatal to information/status).  The \texttt{number} is a unique number that identifies this error message.  \texttt{Params} are the parameters that describe the detail about an error, e.g., the process id where the error occurred.  The number and meaning of params depends on the error.  However, for a given error number the number of parameters returned will always be the same.
}

\subsubsection{Exec}
\manual{
typedef void (*BPatchExecCallback)(BPatch\_thread *thr)\\
BPatchExecCallback registerExecCallback(BPatchExecCallback func) Not implemented on Windows.
 } {
  }

\subsubsection{Exit}

\manual{
typedef enum BPatch\_exitType { NoExit, ExitedNormally, ExitedViaSignal };\\
typedef void (*BPatchExitCallback)(\\
\indent BPatch\_thread *proc, BPatch\_exitType exit\_type);\\
BPatchExitCallback registerExitCallback(
BPatchExitCallback func) }{
Register a function to be called when a process terminates. For a normal process exit, the callback will actually be called just before the process exits, but while its process state still exists.  This allows final actions to be taken on the process before it actually exits.  The function \texttt{BPatch\_thread::isTerminated()} will return true in this context even though the process hasn’t yet actually exited.  In the case of an exit due to a signal, the process will have already exited.
}

\subsubsection{Fork}
\manual{
typedef void (*BPatchForkCallback)(BPatch\_thread *parent, BPatch\_thread *child);}{
This is the prototype for the pre-fork and post-fork callbacks.  The parent parameter is the parent thread, and the child parameter is a BPatch\_thread in the newly created pro-cess. When invoked as a pre-fork callback, the child is \NULL.}

\manual{
BPatchForkCallback registerPreForkCallback(\\
\indent BPatchForkCallback func) not implemented on Windows \\
BPatchForkCallback registerPostForkCallback(\\
\indent BPatchForkCallback func) not implemented on Windows}{
Register callbacks for pre-fork (before the child is created) and post-fork (immediately after the child is created). When a pre-fork callback is executed the child parameter will be \NULL.

}

\subsubsection{One Time Code}
\manual{
typedef void (*BPatchOneTimeCodeCallback)(Bpatch\_thread *thr,\\
\indent void *userData, void *returnValue);\\
BPatchOneTimeCodeCallback registerOneTimeCodeCallback(\\
\indent BPatchOneTimeCodeCallback func)}{
The thr field contains the thread that executed the \texttt{oneTimeCode} (if thread-specific) or an unspecified thread in the process (if process-wide).  The \texttt{userData} field contains the value passed to the oneTimeCode call. The \texttt{returnValue} field contains the return result of the oneTimeCode snippet.
}

\subsubsection{Signal Handler}

\manual{
typedef void (*BPatchSignalHandlerCallback)(BPatch\_point *at\_point,\\
\indent long signum, std::vector<Dyninst::Address> *handlers)\\
bool registerSignalHandlerCallback(BPatchSignalHandlerCallback cb, \\
\indent sstd::set<long> \&signal\_numbers)\\
bool registerSignalHandlerCallback(BPatchSignalHandlerCallback cb, \\
\indent BPatch\_Set<long> *signal\_numbers)\\
bool removeSignalHandlerCallback(BPatchSignalHandlerCallback cb);}{
This function registers the signal handler callback function with the \BPatch class.  The return value indicates success or failure. The signal\_numbers set contains those signal numbers for which the callback will be invoked.\\

The \texttt{at\_point} parameter indicates the point at which the signal/exception was raised, \texttt{signum} is the number of the signal/exception that was raised, and the \texttt{handlers} vector contains any registered handler(s) for the signal/exception.  In Windows this corresponds to the stack of Structured Exception Handlers, while for Unix systems there will be at most one registered exception handler.  This functionality is only fully implemented for the Windows platform. 
}
\subsubsection{Stopped Threads}
\newcommand{\stopThreadExpr}[0]{\texttt{stopThreadExpr}\xspace}
\manual{
typedef void (*BPatchStopThreadCallback)(BPatch\_point *at\_point, void *returnValue)}{
This is the prototype for the callback that is associated with the \stopThreadExpr snippet class (see Section 4.13).  Unlike the other callbacks in this section, \stopThreadExpr callbacks are registered during the creation of the \stopThreadExpr snippet type.  Whenever a \stopThreadExpr snippet executes in a given thread, the snippet evaluates the calculation snippet that \stopThreadExpr takes as a parameter, stops the thread’s execution and invokes this callback.  The \texttt{at\_point} parameter is the \BPatchpoint at which the \stopThreadExpr snippet was inserted, and returnValue contains the computation made by the calculation snippet.  

}
\subsubsection{User-triggered callbacks}

\manual{
typedef void (*BPatchUserEventCallback)(BPatch\_process *proc, void *buf, unsigned int bufsize);
bool registerUserEventCallback(BPatchUserEventCallback cb)
bool removeUserEventCallback(BPatchUserEventCallback cb)}{
Register a callback that is executed when the user sends a message from the mutatee using the \texttt{DYNINSTuserMessage} function in the runtime library. 
}

\subsection{CLASS BPATCH\_ADDRESSSPACE}


The \textbf{\BPatchaddressSpace} class is a superclass of the \BPatchprocess and \BPatchbinaryEdit classes.  It contains functionality that is common between the two sub classes.
 
\manual{BPatch\_image *getImage() }{
Return a handle to the executable file associated with this \BPatchprocess object. }
\newcommand{\addr}[0]{\texttt{addr}\xspace}

\manual{
bool getSourceLines(unsigned long addr, std::vector< BPatch\_statement > \& lines)}{
This function returns the line information associated with the mutatee address, \addr.  The vector \texttt{lines} contain pairs of filenames and line numbers that are associated with \addr.  In many cases only one filename and line number is associated with an address, but certain compiler optimizations may lead to multiple filenames and lines at an address.    This in-formation is only available if the mutatee was compiled with debug information.\\

This function returns \true if it was able to find any line information at addr, or \false otherwise.}

\manual{
bool getAddressRanges( const char * fileName, unsigned int lineNo, std::vector< std::pair< unsigned long, unsigned long > > \& ranges )}{
Given a filename and line number, fileName and lineNo, this function this function re-turns the ranges of mutatee addresses that implement the code range in the output parameter ranges.  In many cases a source code line will only have one address range implementing it. However, compiler optimizations may transform this into multiple disjoint address rang-es.  This information is only available if the mutatee was compiled with debug information.\\

This function returns \true if it was able to find any line information, \false otherwise.}

\manual{BPatch\_variableExpr *malloc(int n, \\
\indent std::string name = std::string("")) \\
BPatch\_variableExpr *malloc(const BPatch\_type \&type,\\
\indent std::string name = std::string("")) }{
These two functions allocate memory. Memory allocation is from a heap. The heap is not necessarily the same heap used by the application. The available space in the heap may be limited depending on the implementation. The first function, \texttt{malloc(int n)}, allocates n bytes of memory from the heap. The second function, \texttt{malloc(const BPatch\_type\& t)}, allocates enough memory to hold an object of the specified type. Using the second version is strongly encouraged because it provides additional information to permit better type checking of the passed code. If a name is specified, Dyninst will assign \texttt{var\_name} to the variable; otherwise, it will assign an internal name. The returned memory is persistent and will not be released until \texttt{BPatch\_process::free} is called or the application terminates.
}

\newcommand{\inmodule}[0]{\texttt{in\_module}\xspace}

\manual{BPatch\_variableExpr *createVariable(Dyninst::Address addr,\\
\indent	BPatch\_type *type,\\
\indent	std::string var\_name = std::string(“”),\\
\indent BPatch\_module *in\_module = NULL)}{
This method creates a new variable at the given address \addr in the module \inmodule.  If a name is specified, Dyninst will assign \texttt{var\_name} to the variable; otherwise, it will assign an internal name.  The type parameter will become the type for the new variable.\\
  
When operating in binary rewriting mode, it is an error for the \inmodule parameter to be \NULL; it is necessary to specify the module in which the variable will be created.  Dyninst will then write the variable back out in the file specified by \inmodule. 
}

\manual{bool free(BPatch\_variableExpr \&ptr) }{
Free the memory in the passed variable \texttt{ptr}. The programmer is responsible for verifying that all code that could reference this memory will not execute again (either by removing all snippets that refer to it, or by analysis of the program). Return \true if the free succeeded.}

\manual{bool getRegisters(std::vector<BPatch\_register> \&regs)}
{
This function returns a vector of \texttt{BPatch\_register} objects that represent registers available to snippet code.}

\manual{BPatchSnippetHandle *insertSnippet(const BPatch\_snippet \&expr, \\
\indent BPatch\_point \&point,\\
\indent BPatch\_callWhen when=[BPatch\_callBefore| BPatch\_callAfter],\\
\indent BPatch\_snipptOerder order = BPatch\_firstSnippet)\\
BPatchSnippetHandle *insertSnippet(const BPatch\_snippet \&expr,\\
\indent const std::vector<BPatch\_point *> \&points,\\
\indent BPatch\_callWhen when=[BPatch\_callBefore| BPatch\_callAfter], \\
\indent BPatch\_snippetOrder order = BPatch\_firstSnippet)}
{
Insert a snippet of code at the specified point. If a list of points is supplied, insert the code snippet at each point in the list. The optional when argument specifies when the snip-pet is to be called; a value of \texttt{BPatch\_callBefore} indicates that the snippet should be inserted just before the specified point or points in the code, and a value of \texttt{BPatch\_callAfter} indicates that it should be inserted just after them. \\

 The order argument specifies where the snippet is to be inserted relative to any other snippets previously inserted at the same point.  The values \texttt{BPatch\_firstSnippet} and \texttt{BPatch\_lastSnippet} indicate that the snippet should be inserted before or after all snip-pets, respectively.\\
 
It is illegal to use \texttt{BPatch\_callAfter} with a \texttt{BPatch\_entry point}.  Use \texttt{BPatch\_callBefore} when instrumenting entry points, which inserts instrumentation be-fore the first instruction in a subroutine.  Likewise, it is illegal to use \texttt{BPatch\_callBefore} with a \texttt{BPatch\_exit} point.  Use \texttt{BPatch\_callAfter} with exit points. \texttt{BPatch\_callAfter} inserts instrumentation at the last instruction in the subroutine. \texttt{insertSnippet} will return \NULL when used with an illegal pair of points.
}


\manual{bool deleteSnippet(BPatchSnippetHandle *handle)}{
Remove the snippet associated with the passed handle.  If the handle is not defined for the process, then deleteSnippet will return \false.}

\newcommand{\beginInsertionSet}[0]{\texttt{beginInsertionSet}\xspace}
\newcommand{\finalizeInsertionSet}[0]{\texttt{finalizeInsertionSet}\xspace}
\newcommand{\BPatchSnippetHandle}[0]{\texttt{BPatchSnippetHandle}\xspace}
\newcommand{\BPatchSnippetHandles}[0]{\texttt{BPatchSnippetHandles}\xspace}

\manual{void beginInsertionSet()}{
Normally, a call to \insertSnippet immediately injects instrumentation into the mutatee. However, users may wish to insert a set of snippets as a single batch operation. This provides two benefits: First, Dyninst may insert instrumentation in a more efficient manner. Second, multiple snippets may be inserted at multiple points as a single operation, with either all snippets being inserted successfully or none. This batch insertion mode is begun with a call to \beginInsertionSet; after this call, no snippets are actually inserted until a corresponding call to finalizeInsertionSet. Dyninst accumulates all calls to \insertSnippet during batch mode internally, and the returned \BPatchSnippetHandles are filled in when \finalizeInsertionSet is called.\\

Insertion sets are unnecessary when doing static binary instrumentation.  Dyninst uses an implicit insertion set around all instrumentation to a static binary.}

\manual{bool finalizeInsertionSet(bool atomic)}{
Inserts all snippets accumulated since a call to \beginInsertionSet. If the atomic parameter is \true, then a failure to insert any snippet results in all snippets being removed; effectively, the insertion is all-or-nothing. If the \texttt{atomic} parameter is false, then snippets are inserted individually. This function also fills in the BPatchSnippetHandle structures returned by the \insertSnippet calls comprising this insertion set.  It returns \true on success and \false if there was an error inserting any snippets.\\

Insertion sets are unnecessary when doing static binary instrumentation.  Dyninst uses an implicit insertion set around all instrumentation to a static binary.}

\manual{bool removeFunctionCall(BPatch\_point \&point)}{
Disable the mutatee function call at the specified location.  The \point specified must be a valid call point in the image of the mutatee. The purpose of this routine is to permit tools to alter the semantics of a program by eliminating procedure calls.  The mechanism to achieve the removal is platform dependent, but might include branching over the call or replacing it with NOPs. This function only removes a function call; any parameters to the function will still be evaluated.}

\manual{
bool replaceFunction (BPatch\_function \&old, BPatch\_function \&new)\\
bool revertReplaceFunction (BPatch\_function \&old)}{
Replace all calls to user function old with calls to new.  This is done by inserting instrumentation (specifically a BPatch\_funcJumpExpr) into the beginning of function old such that a non-returning jump is made to function new.  Returns \true upon success, false otherwise.}

\manual{bool replaceFunctionCall(BPatch\_point \&point, BPatch\_function \&newFunc)}{
Change the function call at the specified point to the function indicated by newFunc. The purpose of this routine is to permit runtime steering tools to change the behavior of pro-grams by replacing a call to one procedure by a call to another. Point must be a function call point. If the change was successful, the return value is true, otherwise false will be returned.\\

WARNING: Care must be used when replacing functions.  In particular if the compiler has performed inter-procedural register allocation between the original caller/callee pair, the replacement may not be safe since the replaced function may clobber registers the compiler thought the callee left untouched. Also the signatures of the both the function be-ing replaced and the new function must be compatible.}

\manual{bool wrapFunction(BPatch\_function *old, BPatch\_function *new, Dyninst::SymtabAPI::Symbol *sym)
bool revertWrapFunction(BPatch\_function *old)}{
Replaces all calls to function old with calls to function new. Unlike replaceFunction above, the old function can still be reached via the name specified by the provided symbol sym. Function wrapping allows existing code to be extended by new code. Consider the follow-ing code that implements a fast memory allocator for a particular size of memory allocation, but falls back to the original memory allocator (referenced by origMalloc) for all others.\\
\texttt{
void *origMalloc(unsigned long size); \\\\
void *fastMalloc(unsigned long size) \{\\
\indent	if (size == 1024) {\\
\indent\indent		unsigned long ret = fastPool; \\
\indent\indent		fastPool += 1024;\\
\indent\indent		return ret;\\
\indent	\}\\
\indent	else \{\\
\indent\indent		return origMalloc(size);\\
\indent	\}\\
\}\\}
}\\

The symbol sym is provided by the user and must exist in the program; the easiest way to ensure it is created is to use an undefined function as shown above with the definition of origMalloc. \\

The following code wraps malloc with fastMalloc, while allowing functions to still ac-cess the original malloc function by calling origMalloc. It makes use of the new convert interface described in Section 5.\\

\texttt{using namespace Dyninst;\\
using namespace SymtabAPI;\\
BPatch\_function *malloc = appImage->findFunction(...);\\
BPatch\_function *fastMalloc = appImage->findFunction(...);\\
Symtab *symtab = SymtabAPI::convert(fastMalloc->getModule());\\
std::vector<Symbol *> syms;\\
symtab->findSymbol(syms, "origMalloc", \\
\indent				Symbol::ST\_UNKNOWN, // Don’t specify type\\
\indent				mangledName, // Look for raw symbol name\\
\indent				false, // Not regular expression\\
\indent				false, // Don’t check case\\
\indent				true); // Include undefined symbols\\
app->wrapFunction(malloc, fastMalloc, syms[0]);
}\\

For a full, executable example, see Appendix~\ref{appdx:complete_examples} Complete Examples.


}




\manual{bool replaceCode(BPatch\_point *point, BPatch\_snippet *snippet)}
{This function has been removed; users interested in replacing code should instead use the PatchAPI code modification interface described in the PatchAPI manual. For information on accessing PatchAPI abstractions from DyninstAPI abstractions, see Section~\ref{sec:using_api}.}

\manual{BPatch\_module * loadLibrary(const char *libname, bool reload=\false)}{
For dynamic rewriting, this function loads a dynamically linked library into the process’s address space.  For static rewriting, this function adds a library as a library dependency in the rewritten file.  In both cases Dyninst creates a new BPatch\_module to represent this library.
The libname parameter identifies the file name of the library to be loaded, in the standard way that dynamically linked libraries are specified on the operating system on which the API is running.  This function returns a handle to the loaded library. The reload parameter is ignored and only remains for backwards compatibility.}

\manual{bool isStaticExecutable()}{
This function returns \true if the original file opened with this \BPatchaddressSpace is a statically linked executable, or \false otherwise.}

\manual{processType getType()}
{This function returns a processType that reflects whether this address space is a \BPatchprocess or a \BPatchbinaryEdit.}


\subsection{CLASS BPATCH\_PROCESS}

The \textbf{\BPatchprocess} class represents a running process, which includes one or more threads of execution and an address space.

\manual{
bool stopExecution() \\
bool continueExecution()\\ 
bool terminateExecution()
}{
These three functions change the running state of the process. \texttt{stopExecution} puts the process into a stopped state. Depending on the operating system, stopping one process may stop all threads associated with a process. \texttt{continueExecution} continues execution of the process.  \texttt{terminateExecution} terminates execution of the process and will invoke the ex-it callback if one is registered. Each function returns true on success, or false for failure.  Stopping or continuing a terminated thread will fail and these functions will return false.
}

\manual{
bool isStopped() \\
int stopSignal() \\
bool isTerminated() }{
These three functions query the status of a process.  \texttt{isStopped} returns true if the process is currently stopped. If the process is stopped (as indicated by \texttt{isStopped}), then \texttt{stopSigsnal} can be called to find out what signal caused the process to stop. \texttt{isTerminated} returns true if the process has exited. Any of these functions may be called multiple times, and call-ing them will not affect the state of the process.
}



\manual{BPatch\_variableExpr *getInheritedVariable(BPatch\_variableExpr \&parentVar) }{
Retrieve a new handle to an existing variable (such as one created by \texttt{BPatch\_process::malloc}) that was created in a parent process and now exists in a forked child process.  When a process forks all existing \texttt{BPatch\_variableExprs} are copied to the child process, but the Dyninst handles for these objects are not valid in the child \texttt{BPatch\_process}.  This function is invoked on the child process’ \texttt{BPatch\_process}, \texttt{parentVar} is a variable from the parent process, and a handle to a variable in the child process is returned.  If \texttt{parentVar} was not allocated in the parent process, then \NULL is returned.}

\manual{BPatchSnippetHandle *getInheritedSnippet(\\
\indent BPatchSnippetHandle \&parentSnippet) }{
This function is similar to getInheritedVariable, but operates on \texttt{BPatchSnippetHandles}.  Given a child process that was created via fork and a \texttt{BPatchSnippetHandle}, \texttt{parentSnippet}, from the parent process, this function will return a handle to \texttt{parentSnippet} that is valid in the child process.  If it is determined that \texttt{parentSnippet} is not associated with the parent process, then \NULL is returned.}

\manual{void detach(bool cont)}{
Detach from the process.  The process must be stopped to call this function.  Instrumentation and other changes to the process will remain active in the detached copy. The cont parameter is used to indicate if the process should be continued as a result of detaching.  \\

Linux does not support detaching from a process while leaving it stopped.  All processes are continued after detach on Linux.}

\manual{int getPid()}
{Return the system id for the mutatee process.  On UNIX based systems this is a PID.  On Windows this is the HANDLE object for a process.}

\manual{typedef enum BPatch\_exitType \{ NoExit, ExitedNormally, ExitedViaSignal \};\\
BPatch\_exitType terminationStatus()}{
If the process has exited, \texttt{terminationStatus} will indicate whether the process exited normally or because of a signal.  If the process has not exited, \texttt{NoExit} will be returned. On AIX, the reason why a process exited will not be available if the process was not a child of the Dyninst mutator; in this case, \texttt{ExitedNormally} will be returned in both normal and signal exit cases.}


\manual{int getExitCode()}{
If the process exited in a normal way, \texttt{getExitCode} will return the associated exit code. Prior to Dyninst 8.2, \texttt{getExitCode} would return the argument passed to \texttt{exit} or the value returned by \texttt{main}; in Dyninst 8.2 and later, it returns the actual exit code as provided by the debug interface and seen by the parent process. In particular, on Linux, this means that exit codes are normalized to the range 0-255.
}


\newcommand{\expr}[0]{\texttt{expr}\xspace}

\manual{int getExitSignal()}{
If the process exited because of a received signal, getExitSignal will return the associated signal number.}
\manual{void oneTimeCode(const BPatch\_snippet \&expr) }{
Cause the snippet \texttt{expr} to be executed by the mutatee immediately. If the process is multi-threaded, the snippet is run on a thread chosen by Dyninst. If the user requires the snippet to be run on a particular thread, use the \BPatchthread version of this function instead. The process must be stopped to call this function.  The behavior is synchronous;\texttt{oneTime-Code} will not return until after the snippet has been run in the application.
}

\manual{bool oneTimeCodeAsync(const BPatch\_snippet \&expr, \\
\indent                      void *userData  = NULL) }{
This function sets up a snippet to be evaluated by the process at the next available opportunity. When the snippet finishes running Dyninst will callback any function registered through \texttt{BPatch::registerOneTimeCodeCallback}, with \texttt{userData} passed as a parameter.  This function return \true on success and \false if it could not post the \texttt{oneTimeCode}.\\

If the process is multithreaded, the snippet is run on a thread chosen by Dyninst. If the user requires the snippet to be run on a particular thread, use the \BPatchthread version of this function instead. The behavior is asynchronous; \texttt{oneTimeCodeAsync} returns before the snippet is executed.\\

If the process is running when \texttt{oneTimeCodeAsync} is called, \texttt{expr} will be run immediately.  If the process is stopped, then \expr will be run when the process is continued.}

\manual{void getThreads(std::vector<BPatch\_thread *> \&thrds)}{
Get the list of threads in the process.
}

\manual{bool isMultithreaded()\\
bool isMultithreadCapable()}{
The former returns true if the process contains multiple threads; the latter returns true if the process can create threads (e.g., it contains a threading library) even if it has not yet. 
}

\subsection{CLASS BPATCH\_THREAD}

The \textbf{\emph{\BPatchthread}} class represents and controls a thread of execution that is running in a pro-cess.


\manual{void getCallStack(std::vector<BPatch\_frame>\& stack)}{
This function fills the given vector with current information about the call stack of the thread.  Each stack frame is represented by a BPatch\_frame }(see section~\ref{sec:bpatch_frame} for information about this class).

\manual{dynthread\_t getTid()}{
This function returns a platform-specific identifier for this thread.  This is the identifier that is used by the threading library.  For example, on pthread applications this function will return the thread’s \texttt{pthread\_t} value.  }

\manual{Dyninst::LWP getLWP()}{
This function returns a platform-specific identifier that the operating system uses to identify this thread.  For example, on UNIX platforms this returns the LWP id.  On Windows this returns a HANDLE object for the thread.}

\manual{unsigned getBPatchID()}{
	This function returns a Dyninst-specific identifier for this thread.  These ID’s apply only to running threads, the BPatch ID of an already terminated thread my be repeated in a new thread.}

\manual{BPatch\_function *getInitialFunc()}{
Return the function that was used by the application to start this thread.  For example, on pthread applications this will return the initial function that was passed to pthread\_create.  }

\manual{unsigned long getStackTopAddr()}{
	Returns the base address for this thread’s stack. 
}

\manual{bool isDeadOnArrival()}{
This function returns \true if this thread terminated execution before Dyninst was able to attach to it.  Since Dyninst performs new thread detection asynchronously, it is possible for a thread to be created and destroyed before Dyninst can attach to it.  When this happens, a new \BPatchthread is created, but \texttt{isDeadOnArrival} always returns \true for this thread.  It is illegal to perform any thread-level operations on a dead on arrival thread.}


\manual{BPatch\_process *getProcess()}{
Return the \BPatchprocess that contains this thread.}

\manual{void *oneTimeCode(const BPatch\_snippet \&expr, bool *err = NULL) }{
Cause the snippet \expr to be evaluated by the process immediately. This is similar to the \texttt{BPatch\_process::oneTimeCode} function, except that the snippet is guaranteed to run only on this thread. The process must be stopped to call this function.  The behavior is synchronous; \texttt{oneTimeCode} will not return until after the snippet has been run in the application.}

\manual{bool oneTimeCodeAsync(const BPatch\_snippet \&expr, 
  void *userData = NULL,
  BpatchOneTimeCodeCallback cb = NULL) }{
This function sets up the snippet expr to be evaluated by this thread at the next available opportunity. When the snippet finishes running, Dyninst will callback any function registered through \texttt{BPatch::registerOneTimeCodeCallback}, with userData passed as a parameter.  This function returns true if \expr was posted or false otherwise.\\

This is similar to the \texttt{BPatch\_process::oneTimeCodeAsync} function, except that the snippet is guaranteed to run only on this thread. The process must be stopped to call this function.  The behavior is asynchronous; \texttt{oneTimeCodeAsync} returns before the snippet is executed.
}


\subsection{CLASS BPATCH\_BINARYEDIT}

The \textbf{\emph{BPatch\_binaryEdit}} class represents a set of executable files and library files for binary rewriting.  \BPatchbinaryEdit inherits from the \BPatchaddressSpace class, where most functionality for binary rewriting is found.

\manual{bool writeFile(const char *outFile)}{
Rewrite a \BPatchbinaryEdit to disk.  The original file opened with this \BPatchbinaryEdit is written to the current working directory with the name outFile.  If any dependent libraries were also opened and have instrumentation or other modifications, then those libraries will be written to disk in the current working directory under their original names.\\
 
A rewritten dependency library should only be used with the original file that was opened for rewriting.  For example, if the file a.out and its dependent library libfoo.so were opened for rewriting, and both had instrumentation inserted, then the rewritten libfoo.so should not be used without the rewritten a.out.  To build a rewritten libfoo.so that can load into any process, libfoo.so must be the original file opened by BPatch::openBinary.\\

This function returns \true if it successfully wrote a file, or \false otherwise.
}


\subsection{CLASS BPATCH\_SOURCEOBJ}
\newcommand{\BPatchsourceObj}[0]{\texttt{BPatch\_sourceObj}\xspace}

The \textbf{\emph{BPatch\_sourceObj}} class is the C++ superclass for the \BPatchfunction, \BPatchmodule, and \BPatchimage classes.  It provides a set of common methods for all three classes.  In addition, it can be used to build a “generic” source navigator using the getObjParent and \texttt{getSourceObj} methods to get parents and children of a given level (i.e. the parent of a module is an image, and the children will be the functions).


\manual{
enum BPatchErrorLevel \{ \\
\indent BPatchFatal, BPatchSerious, BPatchWarning, BPatchInfo \};\\\\
enum BPatch\_sourceType \{ \\
\indent BPatch\_sourceUnknown, \\
\indent BPatch\_sourceProgram,\\
\indent BPatch\_sourceModule, \\
\indent BPatch\_sourceFunction, \\
\indent BPatch\_sourceOuterLoop, \\
\indent BPatch\_sourceLoop, \\
\indent BPatch\_sourceStatement \};\\\\
BPatch\_sourceType getSrcType()}{
Returns the type of the current source object.
}

\newcommand{\BPatchsourceProgram}[0]{\texttt{BPatch\_sourceProgram}\xspace}
\newcommand{\BPatchsourceFunction}[0]{\texttt{BPatch\_sourceFunction}\xspace}
\newcommand{\BPatchsourceOuterLoop}[0]{\texttt{BPatch\_sourceOuterLoop}\xspace}
\newcommand{\BPatchsourceStatement}[0]{\texttt{BPatch\_sourceStatement}\xspace}

\manual{void getSourceObj(std::vector<BPatch\_sourceObj *> \&objs)}{
Returns the child source objects of the current source object.  For example, when called on a \BPatchsourceProgram object this will return objects of type \BPatchsourceFunction.  When called on a \BPatchsourceFunction object it may return \BPatchsourceOuterLoop and \BPatchsourceStatement objects.}

\manual{
BPatch\_sourceObj *getObjParent()}{
Return the parent source object of the current source object.  The parent of a \BPatchimage is \NULL.
}

\manual{
typedef enum BPatch\_language \{\\
\indent    BPatch\_c, \\
\indent     BPatch\_cPlusPlus, \\
\indent     BPatch\_fortran, \\
\indent     BPatch\_fortran77, \\
\indent     BPatch\_fortran90,\\
\indent     BPatch\_f90\_demangled\_stabstr, \\
\indent     BPatch\_fortran95,\\
\indent     BPatch\_assembly, \\
\indent     BPatch\_mixed, \\
\indent     BPatch\_hpf, \\
\indent     BPatch\_java, \\
\indent     BPatch\_unknownLanguage \\
\} BPatch\_language;\\\\BPatch\_language getLanguage() 
}{
Return the source language of the current \texttt{BPatch\_sourceObject}.  For programs that are written in more than one language, \texttt{BPatch\_mixed} will be returned.  If there is insufficient information to determine the language, \texttt{BPatch\_unknownLanguage} will be returned.
}
\subsection{CLASS BPATCH\_FUNCTION}
\subsection{CLASS BPATCH\_POINT}
\subsection{CLASS BPATCH\_IMAGE}
\subsection{CLASS BPATCH\_OBJECT}
\subsection{CLASS BPATCH\_MODULE}
\subsection{CLASS BPATCH\_SNIPPET}
\subsection{CLASS BPATCH\_TYPE}
\subsection{CLASS BPATCH\_VARIABLEEXPR}
\subsection{CLASS BPATCH\_FLOWGRAPH}
\subsection{CLASS BPATCH\_BASICBLOCK}
\subsection{CLASS BPATCH\_EDGE}
\subsection{CLASS BPATCH\_BASICBLOCKLOOP}
\subsection{CLASS BPATCH\_LOOPTREENODE}
\subsection{CLASS BPATCH\_REGISTER}
\subsection{CLASS BPATCH\_SOURCEBLOCK}
\subsection{CLASS BPATCH\_CBLOCK}\label{sec:bpatch_cblock}
\subsection{CLASS BPATCH\_FRAME}\label{sec:bpatch_frame}
\subsection{CLASS STACKMOD}
\subsection{CONTAINER CLASSES}
\subsubsection{Class std::vecotr}
\subsubsection{Class BPatch\_Set}
\subsection{MEMORY ACCESS CLASSES}
\subsubsection{Class BPatch\_memoryAccess}
\subsubsection{Class BPatch\_addrSpec\_NP}
\subsubsection{Class BPatch\_countSpec\_NP}
\subsection{TYPE SYSTEM}\label{sec:type_system}

\pagebreak
